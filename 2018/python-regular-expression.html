<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 5.4.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>Python 之正则表达式 - LEEIF.ME</title>

  
    <meta name="description" content="1. 什么是正则表达式正则表达式：也成为规则表达式，英文名称 Regular Expression，我们在程序中经常会缩写为 regex 或者 regexp，专门用于进行文本检索、匹配、替换等操作的一种技术。注意：正则表达式是一种独立的技术，并不是某编程语言独有的 正则表达式，是一种特殊的符号，这样的符号是需要解释才能使用的，也就是需要正则表达式引擎来进行解释，目前正则表达式的引擎主要分三种：DF">
<meta property="og:type" content="article">
<meta property="og:title" content="Python 之正则表达式">
<meta property="og:url" content="https://leeif.me/2018/python-regular-expression.html">
<meta property="og:site_name" content="LEEIF.ME">
<meta property="og:description" content="1. 什么是正则表达式正则表达式：也成为规则表达式，英文名称 Regular Expression，我们在程序中经常会缩写为 regex 或者 regexp，专门用于进行文本检索、匹配、替换等操作的一种技术。注意：正则表达式是一种独立的技术，并不是某编程语言独有的 正则表达式，是一种特殊的符号，这样的符号是需要解释才能使用的，也就是需要正则表达式引擎来进行解释，目前正则表达式的引擎主要分三种：DF">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-01-20T12:36:25.000Z">
<meta property="article:modified_time" content="2021-03-06T13:52:08.967Z">
<meta property="article:author" content="iliei">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="LEEIF.ME" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" type='image/x-icon' href="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/favicon.svg">
  
</head>

<body theme='light'>
  


  <div class='l_body' id='start'>
    <aside class='l_left'>
    

<header class='header'>
  <div class='logo-wrap'>
  
    <a class='avatar' href='/about/'><img no-lazy src='https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/avatar.png'/></a>
  
  
    <a class='title' href='/'>LEEIF.ME</a>
  
</div>

  <nav class="menu dis-select"><a class="nav-item active" href="/">文章</a><a class="nav-item" href="/wiki/">WIKI</a><a class="nav-item" href="/notes/">笔记</a><a class="nav-item" href="/about/">更多</a></nav>
</header>

<div class='widgets'>
  
    
      
      

  <div class='widget-wrap' id='toc'>
    <div class='widget-header h4 dis-select'>
      <span class='name'>
        
          本文目录
        
      </span>
      <a class='cap-action' id='s-top' title='回到顶部' href='#start'>
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="10505"><path d="M884.526 163.323H208.881c-30.516 0-55.25 24.934-55.25 55.685s24.734 55.685 55.25 55.685h675.645c30.515 0 55.255-24.93 55.255-55.685s-24.74-55.685-55.255-55.685zM568.253 336.87a56.765 56.765 0 0 0-4.06-3.701c-0.63-0.517-1.29-0.968-1.935-1.454-0.799-0.605-1.577-1.224-2.406-1.787-0.779-0.528-1.583-0.978-2.386-1.46-0.748-0.45-1.485-0.926-2.253-1.341-0.81-0.44-1.649-0.814-2.483-1.208-0.8-0.384-1.588-0.784-2.407-1.132-0.814-0.338-1.643-0.61-2.463-0.906-0.875-0.323-1.745-0.66-2.641-0.932-0.825-0.25-1.66-0.435-2.489-0.645-0.916-0.236-1.817-0.492-2.75-0.681-0.962-0.19-1.935-0.307-2.902-0.445-0.814-0.118-1.618-0.272-2.442-0.354a55.163 55.163 0 0 0-5.438-0.276h-0.015c-0.267 0-0.528 0.036-0.794 0.036a54.856 54.856 0 0 0-39.86 16.271l-279.413 281.61c-21.576 21.75-21.576 57.006 0 78.756a54.876 54.876 0 0 0 39.07 16.312 54.835 54.835 0 0 0 39.066-16.312l186.67-188.145V898.09c0 30.75 24.74 55.685 55.256 55.685s55.255-24.934 55.255-55.685v-387.42L769.526 697.22a54.871 54.871 0 0 0 39.065 16.312 54.835 54.835 0 0 0 39.066-16.312c21.576-21.75 21.576-57.006 0-78.756L568.253 336.87z" p-id="10506"></path></svg>
      </a>
    </div>
    <div class='widget-body fs14 post'>
      
        <div class='doc-tree active'>
          <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">1. 什么是正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-text">2. 正则表达式语法结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%87%92%E6%83%B0%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.9 正则表达式的贪婪模式和懒惰模式</span></a></li></ol>
        </div>
      
    </div>
  </div>


    
  
    
      
      <div class='widget-wrap' id='recent'>
  <div class='widget-header h4 dis-select'>
    <span class='name'>最近更新</span>
    
      <a class='cap-action' id='rss' title='Subscribe' href='/atom.xml'>
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8938"><path d="M800.966 947.251c0-404.522-320.872-732.448-716.69-732.448V62.785c477.972 0 865.44 395.987 865.44 884.466h-148.75z m-162.273 0h-148.74c0-228.98-181.628-414.598-405.678-414.598v-152.01c306.205 0 554.418 253.68 554.418 566.608z m-446.24-221.12c59.748 0 108.189 49.503 108.189 110.557 0 61.063-48.44 110.563-108.188 110.563-59.747 0-108.18-49.5-108.18-110.563 0-61.054 48.433-110.556 108.18-110.556z" p-id="8939"></path></svg>
      </a>
    
  </div>
  <div class='widget-body fs14'>
    
    
      <div class='post-title'>
        <a href="/2020/openldap-install-config.html">
          
            OpenLDAP 快速落地实践-部署配置
          
        </a>
      </div>
    
      <div class='post-title'>
        <a href="/2020/openldap-high-ranking.html">
          
            OpenLDAP 快速落地实践-进阶
          
        </a>
      </div>
    
      <div class='post-title'>
        <a href="/2020/openldap-getting-started.html">
          
            OpenLDAP 快速落地实践-基本介绍
          
        </a>
      </div>
    
      <div class='post-title'>
        <a href="/2020/kubernetes-operator.html">
          
            「转」 Kubernetes 控制器的进化之旅
          
        </a>
      </div>
    
      <div class='post-title'>
        <a href="/2019/operator-sdk-use.html">
          
            Opeartor-SDK 简单上手
          
        </a>
      </div>
    
  </div>
</div>

    
  
</div>
<footer class="footer"><div class="social-wrap dis-select"><a class="social" href="/atom.xml" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://7.dusays.com/2021/02/14/25678f144c438.svg"/></a><a class="social" href="https://github.com/leeifme" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/svg/github.svg"/></a><a class="social" href="https://twitter.com/leeifme" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/svg/twitter.svg"/></a><a class="social" href="https://t.me/leeifme" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/svg/telegram.svg"/></a><a class="social" href="/about/#comments" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/svg/comments.svg"/></a></div></footer>

    </aside>
    <div class='l_main'>
      

      


  <div class='bread-nav fs12'>
  
    
    <div id='breadcrumb' style="color:#3fbac2">
      <a class='cap breadcrumb' href='/'>主页</a>
      <span class="sep"></span>
      <a class='cap breadcrumb' href='/'>文章</a>
      
        <span class="sep"></span>
        <a class="cap breadcrumb-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%8A%A0%E6%B2%B9%E7%AB%99/">技术加油站</a>
      
    </div>
    <div id='post-meta'>
      发布于&nbsp;<time datetime='2018-01-20T12:36:25.000Z'>2018-01-20</time>
    </div>
  
  </div>


<article class='content md post reveal'>
<h1 class="article-title"><span>Python 之正则表达式</span></h1>
<h3 id="1-什么是正则表达式"><a href="#1-什么是正则表达式" class="headerlink" title="1. 什么是正则表达式"></a>1. 什么是正则表达式</h3><p>正则表达式：也成为规则表达式，英文名称 Regular Expression，我们在程序中经常会缩写为 regex 或者 regexp，专门用于进行文本检索、匹配、替换等操作的一种技术。<br><em>注意：正则表达式是一种独立的技术，并不是某编程语言独有的</em></p>
<p>正则表达式，是一种特殊的符号，这样的符号是需要解释才能使用的，也就是需要正则表达式引擎来进行解释，目前正则表达式的引擎主要分三种：DFA，NFA、POSIX NFA，<em>有兴趣了正则表达式引擎的童鞋，可以自己查看资料</em></p>
<h3 id="2-正则表达式语法结构"><a href="#2-正则表达式语法结构" class="headerlink" title="2. 正则表达式语法结构"></a>2. 正则表达式语法结构</h3><p>接下来，我们开始了解这样一个神秘的可以类似人类神经网络一样思考问题的技术的语法结构。<br><em>注意：我们通过 python 程序进行测试，但是正则表达式的语法结构在各种语言环境中都是通用的。</em></p>
<h6 id="2-1-入门案例：了解正则表达式"><a href="#2-1-入门案例：了解正则表达式" class="headerlink" title="2.1. 入门案例：了解正则表达式"></a>2.1. 入门案例：了解正则表达式</h6><p>我们通过一个简单的案例入手：通常情况下，我们会验证用户输入的手机号码是否合法，是否 156/186/188 开头的手机号码，如果按照常规验证手段，就需要对字符串进行拆分处理，然后逐步匹配</p>
<blockquote>
<p>重要提示：python 中提供了<code>re</code>模块，包含了正则表达式的所有功能，专门用于进行正则表达式的处理；</p>
</blockquote>
<p>我们首先看一下，常规的手机号码验证过程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">userphone = <span class="built_in">input</span>(<span class="string">&quot;请输入手机号码：&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证用户手机号码是否合法的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validatePhone</span>(<span class="params">phone</span>):</span></span><br><span class="line">    msg = <span class="string">&quot;提示信息：请输入手机号码&quot;</span></span><br><span class="line">    <span class="comment"># 判断输入的字符的长度是否合法</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(phone) == <span class="number">11</span>:</span><br><span class="line">        <span class="comment"># 判断是否156/186/188开头</span></span><br><span class="line">        <span class="keyword">if</span> phone.startswith(<span class="string">&quot;156&quot;</span>) <span class="keyword">or</span> phone.startswith(<span class="string">&quot;186&quot;</span>) <span class="keyword">or</span> phone.startswith(<span class="string">&quot;188&quot;</span>):</span><br><span class="line">            <span class="comment"># 判断每一个字符都是数字</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> phone:</span><br><span class="line">                <span class="comment"># isdigit()函数用于判断调用者是否数字</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> num.isdigit():</span><br><span class="line">                    msg = <span class="string">&quot;不能包含非法字符&quot;</span></span><br><span class="line">                    <span class="keyword">return</span> msg</span><br><span class="line">            msg = <span class="string">&quot;手机号码合法&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = <span class="string">&quot;开头数字不合法&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        msg = <span class="string">&quot;长度不合法&quot;</span></span><br><span class="line">    <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始测试</span></span><br><span class="line">print(validatePhone(userphone))</span><br></pre></td></tr></table></figure>

<p>执行上面的代码，分别输入不同的手机号码，结果如下</p>
<blockquote>
<p>请输入手机号码：188<br>长度不合法</p>
<p>请输入手机号码：15568686868<br>开头数字不合法</p>
<p>请输入手机号码：1566868686a<br>不能包含非法字符</p>
<p>请输入手机号码：15688888888<br>手机号码合法</p>
</blockquote>
<p>我们再次使用正则表达式来改造这段程序<br><em>注意：如果下面的程序中出现了一些语法不是很明白，没关系，后面会详细讲解</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收用户输入</span></span><br><span class="line">userphone = <span class="built_in">input</span>(<span class="string">&quot;请输入手机号码&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义验证手机号码的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validatePhone</span>(<span class="params">phone</span>):</span></span><br><span class="line">    <span class="comment"># 定义正则表达式，Python中的正则表达式还是一个字符串，是以r开头的字符串</span></span><br><span class="line">    regexp = <span class="string">r&quot;^(156|186|188)\d&#123;8&#125;$&quot;</span></span><br><span class="line">    <span class="comment"># 开始验证</span></span><br><span class="line">    <span class="keyword">if</span> re.match(regexp, phone):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;手机号码合法&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;手机号码只能156/186/188开头，并且每一个字符都是数字，请检查&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始验证</span></span><br><span class="line">print(validatePhone(userphone))</span><br></pre></td></tr></table></figure>

<p>执行上面的代码，我们得到正常验证的结果，大家可以自己试一试。<br>我们从这两套代码中，可以看出来，使用了正则表达式之后的程序变得非常简洁了，那保持好你的冲动和热情，让正则表达式来搞事吧</p>
<h6 id="2-3-python-中的正则表达式模块-re"><a href="#2-3-python-中的正则表达式模块-re" class="headerlink" title="2.3. python 中的正则表达式模块 re"></a>2.3. python 中的正则表达式模块 re</h6><p>python 提供的正则表达式处理模块 re，提供了各种正则表达式的处理函数</p>
<p><strong>2.3.1 字符串查询匹配的函数：</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>re.match(reg, info)</td>
<td>用于在<strong>开始位置</strong>匹配目标字符串 info 中符合正则表达式 reg 的字符，匹配成功会返回一个 match 对象，匹配不成功返回 None</td>
</tr>
<tr>
<td>re.search(reg, info)</td>
<td>扫描<strong>整个字符串 info</strong>，使用正则表达式 reg 进行匹配，匹配成功返回匹配的第一个 match 对象，匹配不成功返回 None</td>
</tr>
<tr>
<td>re.findall(reg, info)</td>
<td>扫描<strong>整个字符串 info</strong>，将符合正则表达式 reg 的字符全部提取出来存放在列表中返回</td>
</tr>
<tr>
<td>re.fullmatch(reg, info)</td>
<td>扫描整个字符串，如果整个字符串都包含在正则表达式表示的范围中，返回整个字符串，否则返回 None</td>
</tr>
<tr>
<td>re.finditer(reg, info)</td>
<td>扫描整个字符串，将匹配到的字符保存在一个可以遍历的列表中</td>
</tr>
</tbody></table>
<p>参考官方 re.py 源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span>(<span class="params">pattern, string, flags=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Try to apply the pattern at the start of the string, returning</span></span><br><span class="line"><span class="string">    a match object, or None if no match was found.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> _compile(pattern, flags).match(string)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fullmatch</span>(<span class="params">pattern, string, flags=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Try to apply the pattern to all of the string, returning</span></span><br><span class="line"><span class="string">    a match object, or None if no match was found.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> _compile(pattern, flags).fullmatch(string)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">pattern, string, flags=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Scan through string looking for a match to the pattern, returning</span></span><br><span class="line"><span class="string">    a match object, or None if no match was found.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> _compile(pattern, flags).search(string)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findall</span>(<span class="params">pattern, string, flags=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return a list of all non-overlapping matches in the string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If one or more capturing groups are present in the pattern, return</span></span><br><span class="line"><span class="string">    a list of groups; this will be a list of tuples if the pattern</span></span><br><span class="line"><span class="string">    has more than one group.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Empty matches are included in the result.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> _compile(pattern, flags).findall(string)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">finditer</span>(<span class="params">pattern, string, flags=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return an iterator over all non-overlapping matches in the</span></span><br><span class="line"><span class="string">    string.  For each match, the iterator returns a match object.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Empty matches are included in the result.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> _compile(pattern, flags).finditer(string)</span><br></pre></td></tr></table></figure>

<p><strong>2.3.2 字符串拆分替换的函数：</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>re.split(reg, string)</td>
<td>使用指定的正则表达式 reg 匹配的字符，将字符串 string 拆分成一个字符串列表，如：re.split(r”\s+”, info)，表示使用一个或者多个空白字符对<strong>字符串 info</strong> 进行拆分，并返回一个拆分后的字符串列表</td>
</tr>
<tr>
<td>re.sub(reg, repl, string)</td>
<td>使用<strong>指定的字符串 repl</strong> 来<strong>替换目标字符串 string</strong> 中<strong>匹配正则表达式 reg</strong> 的字符</td>
</tr>
</tbody></table>
<p>参考官方源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span>(<span class="params">pattern, string, maxsplit=<span class="number">0</span>, flags=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Split the source string by the occurrences of the pattern,</span></span><br><span class="line"><span class="string">    returning a list containing the resulting substrings.  If</span></span><br><span class="line"><span class="string">    capturing parentheses are used in pattern, then the text of all</span></span><br><span class="line"><span class="string">    groups in the pattern are also returned as part of the resulting</span></span><br><span class="line"><span class="string">    list.  If maxsplit is nonzero, at most maxsplit splits occur,</span></span><br><span class="line"><span class="string">    and the remainder of the string is returned as the final element</span></span><br><span class="line"><span class="string">    of the list.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> _compile(pattern, flags).split(string, maxsplit)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span>(<span class="params">pattern, repl, string, count=<span class="number">0</span>, flags=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the string obtained by replacing the leftmost</span></span><br><span class="line"><span class="string">    non-overlapping occurrences of the pattern in string by the</span></span><br><span class="line"><span class="string">    replacement repl.  repl can be either a string or a callable;</span></span><br><span class="line"><span class="string">    if a string, backslash escapes in it are processed.  If it is</span></span><br><span class="line"><span class="string">    a callable, it&#x27;s passed the match object and must return</span></span><br><span class="line"><span class="string">    a replacement string to be used.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> _compile(pattern, flags).sub(repl, string, count)</span><br></pre></td></tr></table></figure>

<p>接下来，我们进入正则表达式干货部分</p>
<h6 id="2-4-正则表达式中的元字符"><a href="#2-4-正则表达式中的元字符" class="headerlink" title="2.4. 正则表达式中的元字符"></a>2.4. 正则表达式中的元字符</h6><p>在使用正则表达式的过程中，一些包含特殊含义的字符，用于表示字符串中一些特殊的位置，非常重要，我们先简单了解一下一些常用的元字符</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>表示匹配字符串的开头位置的字符</td>
</tr>
<tr>
<td>$</td>
<td>表示匹配字符串的结束位置的字符</td>
</tr>
<tr>
<td>.</td>
<td>表示匹配任意一个字符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字字符</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符</td>
</tr>
<tr>
<td>\s</td>
<td>匹配一个空白字符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配一个非空白字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配一个数字 / 字母 / 下划线中任意一个字符</td>
</tr>
<tr>
<td>\W</td>
<td>匹配一个非数字字母下划线的任意一个字符</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词的边界</td>
</tr>
<tr>
<td>\B</td>
<td>匹配不是单词的开头或者结束位置</td>
</tr>
</tbody></table>
<p>上干货：代码案例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入正则表达式模块</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义测试文本字符串，我们后续在这段文本中查询数据</span></span><br><span class="line">msg1 = <span class="string">&quot;&quot;&quot;Python is an easy to learn, powerful programming language.</span></span><br><span class="line"><span class="string">It has efficient high-level data structures and a simple but effective approach to object-oriented programming.</span></span><br><span class="line"><span class="string">Python’s elegant syntax and dynamic typing, together with its interpreted nature, </span></span><br><span class="line"><span class="string">make it an ideal language for scripting and rapid application development in many areas on most platforms.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">msg2 = <span class="string">&quot;hello&quot;</span></span><br><span class="line">msg3 = <span class="string">&quot;hello%&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义正则表达式，匹配字符串开头是否为python</span></span><br><span class="line">regStart = <span class="string">r&quot;efficient&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从字符串开始位置匹配，是否包含符合正则表达式的内容，返回匹配到的字符串的Match对象</span></span><br><span class="line">print(re.match(regStart, msg1))</span><br><span class="line"><span class="comment"># 扫描整个字符串，是否包含符合正则表达式的内容，返回匹配到的第一个字符串的Match对象</span></span><br><span class="line">print(re.search(regStart, msg1))</span><br><span class="line"><span class="comment"># 扫描整个字符串，是否包含符合正则表达式的内容，返回匹配到的所有字符串列表</span></span><br><span class="line">print(re.findall(regStart, msg1))</span><br><span class="line"><span class="comment"># 扫描整个字符串，是否包含符合正则表达式的内容，返回匹配到的字符串的迭代对象</span></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> re.finditer(regStart, msg1):</span><br><span class="line">    print(<span class="string">&quot;-&gt;&quot;</span>+ r.group())</span><br><span class="line"><span class="comment"># 扫描整个字符串，是否包含在正则表达式匹配的内容中，是则返回整个字符串，否则返回None</span></span><br><span class="line">print(re.fullmatch(<span class="string">r&quot;\w*&quot;</span>, msg2))</span><br><span class="line">print(re.fullmatch(<span class="string">r&quot;\w*&quot;</span>, msg3))</span><br></pre></td></tr></table></figure>

<p>上述代码执行结果如下：</p>
<blockquote>
<p>~ None<br>~&lt;sre.SRE_Match object; span=(66, 75), match=’efficient’&gt;<br>~[‘efficient’]<br>~-&gt;efficient<br>~&lt;sre.SRE_Match object; span=(0, 5), match=’hello’&gt;<br>~None</p>
</blockquote>
<h6 id="2-5-正则表达式中的量词"><a href="#2-5-正则表达式中的量词" class="headerlink" title="2.5. 正则表达式中的量词"></a>2.5. 正则表达式中的量词</h6><p>正则表达式中的量词，是用于限定数量的特殊字符</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>x*</td>
<td>用于匹配符号 * 前面的字符出现 0 次或者多次</td>
</tr>
<tr>
<td>x+</td>
<td>用于匹配符号 + 前面的字符出现 1 次或者多次</td>
</tr>
<tr>
<td>x？</td>
<td>用于匹配符号？前面的字符出现 0 次或者 1 次</td>
</tr>
<tr>
<td>x{n}</td>
<td>用于匹配符号 {n} 前面的字符出现 n 次</td>
</tr>
<tr>
<td>x{m,n}</td>
<td>用于匹配符号 {m,n} 前面的字符出现至少 m 次，最多 n 次</td>
</tr>
<tr>
<td>x{n,}</td>
<td>用于匹配符号 {n,} 前面的字符出现至少 n 次</td>
</tr>
</tbody></table>
<p>接上代码干货：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入正则表达式模块</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义测试文本字符串，我们后续在这段文本中查询数据</span></span><br><span class="line">msg1 = <span class="string">&quot;&quot;&quot;goodgoodstudy!,dooodooooup&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配一段字符串中出现单词o字符0次或者多次的情况</span></span><br><span class="line">print(re.findall(<span class="string">r&quot;o*&quot;</span>, msg1))</span><br><span class="line"><span class="comment"># 匹配一段字符串中出现单词o字符1次或者多次的情况</span></span><br><span class="line">print(re.findall(<span class="string">r&quot;o+&quot;</span>, msg1))</span><br><span class="line"><span class="comment"># 匹配一段字符串中出现单词o字符0次或者1次的情况</span></span><br><span class="line">print(re.findall(<span class="string">r&quot;o?&quot;</span>, msg1))</span><br><span class="line"><span class="comment"># 匹配字符串中连续出现2次字符o的情况</span></span><br><span class="line">print(re.findall(<span class="string">r&quot;o&#123;2&#125;&quot;</span>, msg1))</span><br><span class="line"><span class="comment"># 匹配字符串中连续出现2次以上字符o的情况</span></span><br><span class="line">print(re.findall(<span class="string">r&quot;o&#123;2,&#125;&quot;</span>, msg1))</span><br><span class="line"><span class="comment"># 匹配字符串中连续出现2次以上3次以内字符o的情况</span></span><br><span class="line">print(re.findall(<span class="string">r&quot;o&#123;2,3&#125;&quot;</span>, msg1))</span><br></pre></td></tr></table></figure>

<p>上述代码大家可以自行尝试并分析结果。执行结果如下：</p>
<h6 id="2-6-正则表达式中的范围匹配"><a href="#2-6-正则表达式中的范围匹配" class="headerlink" title="2.6. 正则表达式中的范围匹配"></a>2.6. 正则表达式中的范围匹配</h6><p>在正则表达式中，针对字符的匹配，除了快捷的元字符的匹配，还有另一种使用方括号进行的范围匹配方式，具体如下：</p>
<table>
<thead>
<tr>
<th>范围</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[0-9]</td>
<td>用于匹配一个 0~9 之间的数字，等价于 \ d</td>
</tr>
<tr>
<td>[^0-9]</td>
<td>用于匹配一个非数字字符，等价于 \ D</td>
</tr>
<tr>
<td>[3-6]</td>
<td>用于匹配一个 3~6 之间的数字</td>
</tr>
<tr>
<td>[a-z]</td>
<td>用于匹配一个 a~z 之间的字母</td>
</tr>
<tr>
<td>[A-Z]</td>
<td>用于匹配一个 A~Z 之间的字母</td>
</tr>
<tr>
<td>[a-f]</td>
<td>用于匹配一个 a~f 之间的字母</td>
</tr>
<tr>
<td>[a-zA-Z]</td>
<td>用于匹配一个 a~z 或者 A-Z 之间的字母，匹配任意一个字母</td>
</tr>
<tr>
<td>[a-zA-Z0-9]</td>
<td>用于匹配一个字母或者数字</td>
</tr>
<tr>
<td>[a-zA-Z0-9_]</td>
<td>用于匹配一个字母或者数字或者下划线，等价于 \ w</td>
</tr>
<tr>
<td>[^a-zA-Z0-9_]</td>
<td>用于匹配一个非字母或者数字或者下划线，等价于 \ W</td>
</tr>
</tbody></table>
<p><em>注意：不要使用 [0-120] 来表示 0~120 之间的数字，这是错误的</em></p>
<p>整理测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入正则表达式模块</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">msg = <span class="string">&quot;Hello, The count of Today is 800&quot;</span></span><br><span class="line"><span class="comment"># 匹配字符串msg中所有的数字</span></span><br><span class="line">print(re.findall(<span class="string">r&quot;[0-9]+&quot;</span>, msg))</span><br><span class="line"><span class="comment"># 匹配字符串msg中所有的小写字母</span></span><br><span class="line">print(re.findall(<span class="string">r&quot;[a-z]+&quot;</span>, msg))</span><br><span class="line"><span class="comment"># 匹配字符串msg中所有的大写字母</span></span><br><span class="line">print(re.findall(<span class="string">r&quot;[A-Z]+&quot;</span>, msg))</span><br><span class="line"><span class="comment"># 匹配字符串msg中所有的字母</span></span><br><span class="line">print(re.findall(<span class="string">r&quot;[A-Za-z]+&quot;</span>, msg))</span><br></pre></td></tr></table></figure>

<p>上述代码执行结果如下：</p>
<blockquote>
<p>[‘800’]<br>[‘ello’, ‘he’, ‘count’, ‘of’, ‘oday’, ‘is’]<br>[‘H’, ‘T’, ‘T’]<br>[‘Hello’, ‘The’, ‘count’, ‘of’, ‘Today’, ‘is’]</p>
</blockquote>
<h6 id="2-7-正则表达式中的分组"><a href="#2-7-正则表达式中的分组" class="headerlink" title="2.7. 正则表达式中的分组"></a>2.7. 正则表达式中的分组</h6><p>正则表达式主要是用于进行字符串检索匹配操作的利器<br>在一次完整的匹配过程中，可以将匹配到的结果进行分组，这样就更加的细化了我们对匹配结果的操作<br>正则表达式通过圆括号 () 进行分组，以提取匹配结果的部分结果</p>
<p>常用的两种分组：</p>
<table>
<thead>
<tr>
<th>分组</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>(expression)</td>
<td>使用圆括号直接分组；正则表达式本身匹配的结果就是一个组，可以通过 group() 或者 group(0) 获取；然后正则表达式中包含的圆括号就是按照顺序从 1 开始编号的小组</td>
</tr>
<tr>
<td>(?P<name>expression)</td>
<td>使用圆括号分组，然后给当前的圆括号表示的小组命名为 name，可以通过 group(name) 进行数据的获取</td>
</tr>
</tbody></table>
<p>废话少说，上干货：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入正则表达式模块</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户输入座机号码，如&quot;010-6688465&quot;</span></span><br><span class="line">phone = <span class="built_in">input</span>(<span class="string">&quot;请输入座机号码：&quot;</span>)</span><br><span class="line"><span class="comment"># 1.进行正则匹配,得到Match对象，对象中就包含了分组信息</span></span><br><span class="line">res1 = re.search(<span class="string">r&quot;^(\d&#123;3,4&#125;)-(\d&#123;4,8&#125;)$&quot;</span>, phone)</span><br><span class="line"><span class="comment"># 查看匹配结果</span></span><br><span class="line">print(res1)</span><br><span class="line"><span class="comment"># 匹配结果为默认的组，可以通过group()或者group(0)获取</span></span><br><span class="line">print(res1.group())</span><br><span class="line"><span class="comment"># 获取结果中第一个括号对应的组数据：处理区号</span></span><br><span class="line">print(res1.group(<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 获取结果中第二个括号对应的组数据：处理号码</span></span><br><span class="line">print(res1.group(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.进行正则匹配,得到Match对象，对象中就包含了命名分组信息</span></span><br><span class="line">res2 = re.search(<span class="string">r&quot;^(?P&lt;nstart&gt;\d&#123;3,4&#125;)-(?P&lt;nend&gt;\d&#123;4,8&#125;)$&quot;</span>, phone)</span><br><span class="line"><span class="comment"># 查看匹配结果</span></span><br><span class="line">print(res2)</span><br><span class="line"><span class="comment"># 匹配结果为默认的组，可以通过group()或者group(0)获取</span></span><br><span class="line">print(res2.group(<span class="number">0</span>))</span><br><span class="line"><span class="comment"># 通过名称获取指定的分组信息：处理区号</span></span><br><span class="line">print(res2.group(<span class="string">&quot;nstart&quot;</span>))</span><br><span class="line"><span class="comment"># 通过名称获取指定分组的信息：处理号码</span></span><br><span class="line">print(res2.group(<span class="string">&quot;nend&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>上述代码就是从原始字符串中，通过正则表达式匹配得到一个结果，但是使用了分组之后，就可以将结果数据通过分组进行细化处理，执行结果如下：</p>
<blockquote>
<p>请输入座机号码：021-6565789<br>&lt;_sre.SRE_Match object; span=(0, 11), match=’021-6565789’&gt;<br>021-6565789<br>021<br>6565789<br>&lt;_sre.SRE_Match object; span=(0, 11), match=’021-6565789’&gt;<br>021-6565789<br>021<br>6565789</p>
</blockquote>
<h6 id="2-8-正则表达式中的特殊用法"><a href="#2-8-正则表达式中的特殊用法" class="headerlink" title="2.8. 正则表达式中的特殊用法"></a>2.8. 正则表达式中的特殊用法</h6><p>使用分组的同时，会有一些特殊的使用方式如下：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>(?:expression)</td>
<td>作为正则表达式的一部分，但是匹配结果丢弃</td>
</tr>
<tr>
<td>(?=expression)</td>
<td>匹配 expression 表达式前面的字符，如 “How are you doing” , 正则 “(?<txt>.+(?=ing))” 这里取 ing 前所有的字符，并定义了一个捕获分组名字为 “txt” 而 “txt” 这个组里的值为 “How are you do”</td>
</tr>
<tr>
<td>(?&lt;=expression)</td>
<td>匹配 expression 表达式后面的字符，如 “How are you doing” 正则 “(?<txt>(?&lt;=How).+)”这里取”How”之后所有的字符，并定义了一个捕获分组名字为”txt”而”txt”这个组里的值为” are you doing”;</td>
</tr>
<tr>
<td>(?!expression)</td>
<td>匹配字符串后面不是 expression 表达式字符，如 “123abc” 正则 “\d{3}(?!\d)” 匹配 3 位数字后非数字的结果</td>
</tr>
<tr>
<td>(?&lt;!expression)</td>
<td>匹配字符串前面不是 expression 表达式字符，如 “abc123” 正则 “(?&lt;![0-9])123”匹配”123”前面是非数字的结果也可写成”(?!&lt;\d)123”</td>
</tr>
</tbody></table>
<h3 id="2-9-正则表达式的贪婪模式和懒惰模式"><a href="#2-9-正则表达式的贪婪模式和懒惰模式" class="headerlink" title="2.9 正则表达式的贪婪模式和懒惰模式"></a>2.9 正则表达式的贪婪模式和懒惰模式</h3><p>在某些情况下，我们匹配的字符串出现一些特殊的规律时，就会出现匹配结果不尽如人意的意外情况<br>如：在下面的字符串中，将 div 标签中的所有内容获取出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;内容1&lt;&#x2F;div&gt;&lt;p&gt;这本来是不需要的内容&lt;&#x2F;p&gt;&lt;div&gt;内容2&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>此时，我们想到的是，使用 <div> 作为关键信息进行正则表达式的定义，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regexp &#x3D; r&quot;&lt;div&gt;.*&lt;&#x2F;div&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>本意是使用上述代码来完成 div 开始标签和结束标签之间的内容匹配，但是，匹配的结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt; [内容1&lt;&#x2F;div&gt;&lt;p&gt;这本来是不需要的内容&lt;&#x2F;p&gt;&lt;div&gt;内容2] &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，上面匹配的结果，是将字符串开头的 <div> 标签和字符串结束的 </div> 当成了匹配元素，对包含在中间的内容直接进行了匹配，也就得到了我们期望之外的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内容1&lt;&#x2F;div&gt;&lt;p&gt;这本来是不需要的内容&lt;&#x2F;p&gt;&lt;div&gt;内容2</span><br></pre></td></tr></table></figure>

<p>上述就是我们要说的正则表达式的第一种模式：贪婪模式<br><strong>贪婪模式</strong>：正则表达式匹配的一种模式，速度快，但是匹配的内容会从字符串两头向中间搜索匹配（比较贪婪~），一旦匹配选中，就不继续向字符串中间搜索了，过程如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开始：<span class="tag">&lt;<span class="name">div</span>&gt;</span>内容1<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>这本来是不需要的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>内容2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">第一次匹配：【<span class="tag">&lt;<span class="name">div</span>&gt;</span>内容1<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>这本来是不需要的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>内容2<span class="tag">&lt;/<span class="name">div</span>&gt;</span>】</span><br><span class="line"></span><br><span class="line">第二次匹配<span class="tag">&lt;<span class="name">div</span>&gt;</span>【内容1<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>这本来是不需要的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>内容2】<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">匹配到正则中需要的结果，不再继续匹配，直接返回匹配结果如下：</span><br><span class="line">内容1<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>这本来是不需要的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>内容2</span><br></pre></td></tr></table></figure>

<p>明显贪婪模式某些情况下，不是我们想要的，所以出现了另一种模式：懒惰模式<br><strong>懒惰模式</strong>：正则表达式匹配的另一种模式，会首先搜索匹配正则表达式开始位置的字符，然后逐步向字符串的结束位置查找，一旦找到匹配的就返回，然后接着查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regexp &#x3D; r&quot;&lt;div&gt;.*?&lt;&#x2F;div&gt;&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">开始：<span class="tag">&lt;<span class="name">div</span>&gt;</span>内容1<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>这本来是不需要的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>内容2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">第一次匹配：【<span class="tag">&lt;<span class="name">div</span>&gt;</span>】内容1<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>这本来是不需要的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>内容2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">第二次匹配【<span class="tag">&lt;<span class="name">div</span>&gt;</span>内容1<span class="tag">&lt;/<span class="name">div</span>&gt;</span>】<span class="tag">&lt;<span class="name">p</span>&gt;</span>这本来是不需要的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>内容2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">匹配到正则中需要的结果：内容1</span><br><span class="line"></span><br><span class="line">继续向后查找</span><br><span class="line"></span><br><span class="line">第三次匹配<span class="tag">&lt;<span class="name">div</span>&gt;</span>内容1<span class="tag">&lt;/<span class="name">div</span>&gt;</span>【<span class="tag">&lt;<span class="name">p</span>&gt;</span>这本来是不需要的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span>】<span class="tag">&lt;<span class="name">div</span>&gt;</span>内容2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">第四次匹配<span class="tag">&lt;<span class="name">div</span>&gt;</span>内容1<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>这本来是不需要的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span>【<span class="tag">&lt;<span class="name">div</span>&gt;</span>内容2<span class="tag">&lt;/<span class="name">div</span>&gt;</span>】</span><br><span class="line"></span><br><span class="line">匹配到正则中需要的结果：内容2</span><br><span class="line"></span><br><span class="line">查找字符串结束！</span><br></pre></td></tr></table></figure>

<blockquote>
<p>正则表达式匹配的两种模式：贪婪模式、懒惰模式<br><strong>贪婪模式</strong>：从目标字符串的两头开始搜索，一次尽可能多的匹配符合条件的字符串，但是有可能会匹配到不需要的内容，正则表达式中的元字符、量词、范围等都模式是贪婪匹配模式，使用的时候一定要注意分析结果，如：<code>&lt;div&gt;.*&lt;/div&gt;</code>就是一个贪婪模式，用于匹配 <div> 和 </div> 之间所有的字符<br><strong>懒惰模式</strong>：从目标字符串按照顺序从头到位进行检索匹配，尽可能的检索到最小范围的匹配结果，语法结构是在贪婪模式的表达式后面加上一个符号? 即可，如<code>&lt;div&gt;.*?&lt;/div&gt;</code>就是一个懒惰模式的正则，用于仅仅匹配最小范围的 <div> 和 </div> 之间的内容</p>
<p>不论贪婪模式还是懒惰模式，都有适合自己使用的地方，大家一定要根据实际需求进行解决方案的确定</p>
</blockquote>
<p><strong>转载: <a target="_blank" rel="noopener" href="https://www.imooc.com/article/22158">https://www.imooc.com/article/22158</a></strong></p>


<div class="article-footer fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section><section id="share"><div class="header"><span>分享文章</span></div><div class="body"><div class="link"><input class="copy-area" readonly="true" id="copy-link" value="https://leeif.me/2018/python-regular-expression.html" /></div><div class="social-wrap"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot)"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/social/b32ef3da1162a.svg"/></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=https://leeif.me/2018/python-regular-expression.html&title=Python 之正则表达式 - LEEIF.ME&summary=1. 什么是正则表达式正则表达式：也成为规则表达式，英文名称 Regular Expression，我们在程序中经常会缩写为 regex 或者 regexp，专门用于进行文本检索、匹配、替换等操作的一种技术。注意：正则表达式是一种独立..."><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/social/80c07e4dbb303.svg"/></a><a class="social share-item email" href="mailto:?subject=Python 之正则表达式 - LEEIF.ME&amp;body=https://leeif.me/2018/python-regular-expression.html"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/social/a1b00e20f425d.svg"/></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/social/8411ed322ced6.svg"/></a></div><div class="qrcode" id="qrcode-wechat" style="display:none"><img no-lazy src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=https://leeif.me/2018/python-regular-expression.html"/ onerror="javascript:this.classList.add('error');this.src='https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/image/2659360.svg';"></div></div></section></div>

</article>

<div class="related-wrap" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body"><div class="post-title h2"><a href="/2018/babun-windows-tool.html">Windows 利器 - babun</a></div><div class="post-title fs14"><a href="/2017/mgo-connection-mongodb-experience.html">更早一篇：mgo 连接 MongoDB 数据库的使用实例</a></div></section></div>

<div class='related-wrap' id='related-posts'>
    <section class='header'>
      <div class='title cap theme'>您可能感兴趣的文章</div>
    </section>
    <section class='body'>
    <div class="related-posts"><a class="item" href="\2017\python-virtual-environment-build.html" title="Python 虚拟坏境的搭建和配置"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/cover/20210307212003.png" /></div><span class="title">Python 虚拟坏境的搭建和配置</span></a><a class="item" href="\2019\deploy-airflow.html" title="搭建 Airflow 任务调度环境"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/cover/20210307212003.png" /></div><span class="title">搭建 Airflow 任务调度环境</span></a><a class="item" href="\2017\common-sorting-algorithm.html" title="常见排序算法"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/cover/20210307212003.png" /></div><span class="title">常见排序算法</span><span class="excerpt">时间复杂度为O(n2)  空间复杂度O(1)

冒泡排序
（在0N-1的序列上相邻两个元素比较大小，大的在后，小的在前，一趟下来，最大值放在位置N-1上，在0N-2的序列上….）

选择排序
（在0N-1的序列中选择最小值放在位置0上...</span></a></div></section></div>



  <div class='related-wrap md' id="comments">
    <div class='cmt-title cap theme'>
      快来参与讨论吧
    </div>
    <div class='cmt-body utterances'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="utterances" repo="leeifme/blog-comments" issue-term="pathname" theme="github-light"></div>

    </div>
  </div>



      
<footer class="page-footer fs12"><hr><div><p>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
<p>本站由 <a href="https://leeif.me/">@iliei</a> 创建，使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.0.0-rc.6">Stellar</a> 作为主题。</p>
</div></footer>

      <div class='float-panel mobile-only' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" viewBox="0 0 1228 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2849"><path d="M0 0m97.390199 0l973.901995 0q97.390199 0 97.390199 97.390199l0 0q0 97.390199-97.390199 97.3902l-973.901995 0q-97.390199 0-97.390199-97.3902l0 0q0-97.390199 97.390199-97.390199Z" p-id="2850"></path><path d="M0 389.560798m97.390199 0l973.901995 0q97.390199 0 97.390199 97.390199l0 0q0 97.390199-97.390199 97.3902l-973.901995 0q-97.390199 0-97.390199-97.3902l0 0q0-97.390199 97.390199-97.390199Z" p-id="2851"></path><path d="M0 779.121596m97.390199 0l973.901995 0q97.390199 0 97.390199 97.390199l0 0q0 97.390199-97.390199 97.390199l-973.901995 0q-97.390199 0-97.390199-97.390199l0 0q0-97.390199 97.390199-97.390199Z" p-id="2852"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {};
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.0.0-rc.6';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper/swiper-bundle.min.css","js":"https://unpkg.com/swiper/swiper-bundle.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function utterances(){
    if(!document.getElementById("utterances"))return;
    setTimeout(function() {
      var checkUtterances = setInterval(function () {
        var el = document.getElementById("utterances");
        if (!el) return
        clearInterval(checkUtterances)
        try {
          el.innerHTML="";
        } catch (error) {}
        var script = document.createElement('script');
        script.src = 'https://utteranc.es/client.js';
        const keys = ['repo', 'issue-term', 'issue-number', 'theme', 'label', 'crossorigin'];
        keys.forEach((key, i) => {
          if (el.attributes[key] && el.attributes[key].value) {
            script.setAttribute(key, el.attributes[key].value);
          }
        });
        el.appendChild(script);
       }, 200)
    });
  }
  utterances();
</script>




<!-- inject -->


  </div>
</body>
</html>
