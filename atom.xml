<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LLIEI0X</title>
  
  <subtitle>☔ slow to respond |🌵 Live long and prosper</subtitle>
  <link href="https://liei.cc/atom.xml" rel="self"/>
  
  <link href="https://liei.cc/"/>
  <updated>2020-08-01T07:15:15.000Z</updated>
  <id>https://liei.cc/</id>
  
  <author>
    <name>lliei0x</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenLDAP 快速落地实践-进阶</title>
    <link href="https://liei.cc/2020/openldap-high-ranking.html"/>
    <id>https://liei.cc/2020/openldap-high-ranking.html</id>
    <published>2020-08-01T07:15:15.000Z</published>
    <updated>2020-08-01T07:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2><blockquote><p>主要介绍如何备份 OpenLDAP 的配置目录和数据目录，并将其恢复到另一个 OpenLDAP 服务中</p></blockquote><h3 id="OpenLDAP-的备份"><a href="#OpenLDAP-的备份" class="headerlink" title="OpenLDAP 的备份"></a>OpenLDAP 的备份</h3><p>OpenLDAP 的备份可以通过服务端的 <code>slapcat</code> 命令或客户端的 <code>ldapsearch</code> 命令两种方式进行。下面展示了如何在 OpenLDAP 服务端使用 <code>slapcat</code> 对配置目录和数据目录进行导出。</p><pre><code class="hljs plain">$ slapcat -n 0 -l .&#x2F;config.&#96;date &#39;+%Y-%m-%d&#39;&#96;.ldif$ slapcat -n 2 -l .&#x2F;data.&#96;date &#39;+%Y-%m-%d&#39;&#96;.ldif</code></pre><p>其中，<code>-n</code> 表示要导出的 OpenLDAP 数据库编号</p><h3 id="OpenLDAP-的恢复"><a href="#OpenLDAP-的恢复" class="headerlink" title="OpenLDAP 的恢复"></a>OpenLDAP 的恢复</h3><div class="tag-plugin timeline"><div class="timenode" item="1"><div class="header"><p>在开始恢复之前，需要先暂停 OpenLDAP 服务</p></div><div class="body fs14"><p>$ systemctl stop slapd</p></div></div><div class="timenode" item="2"><div class="header"><p>OpenLDAP 配置目录一般位于 <code>/etc/openldap/slapd.d</code>，我们需要先将原有配置删除，然后使用 <code>slapadd</code> 导入新的配置</p></div><div class="body fs14"><p>$ rm -rf /etc/openldap/slapd.d/*<br>$ slapadd -n 0 -F /etc/openldap/slapd.d -l ./config.2019-01-04.ldif<br>$ chown -R ldap:ldap /etc/openldap/slapd.d</p></div></div><div class="timenode" item="3"><div class="header"><p>2020-04-20 OpenLDAP 数据目录一般位于 <code>/var/lib/ldap</code>，同样的我们需要先将原有数据删除，然后使用 <code>slapadd</code> 导入新的数据</p></div><div class="body fs14"><p>$ rm -rf /var/lib/ldap/*<br>$ slapadd -n 2 -F /etc/openldap/slapd.d -l ./data.2019-01-04.ldif<br>$ chown -R ldap:ldap /var/lib/ldap</p></div></div><div class="timenode" item="4"><div class="header"><p>最后，重启 OpenLDAP 服务即可</p></div><div class="body fs14"><p>$ systemctl start slapd</p></div></div></div><h2 id="添加-memberof-支持"><a href="#添加-memberof-支持" class="headerlink" title="添加 memberof 支持"></a>添加 memberof 支持</h2><blockquote><p>如果使用 LDAP 仅仅作为用户统一登录中心，则参考安装文档即可；如果 ldap 要与第三方软件结合，例如 confluence、gitlab 等结合，则需要开启 memberof 支持</p></blockquote><ol><li>开启 memberof 支持。</li></ol><pre><code class="hljs yaml"><span class="hljs-string">vim</span> <span class="hljs-number">1</span><span class="hljs-string">-load-memberof.ldif</span><span class="hljs-string">内容如下：</span><span class="hljs-attr">dn:</span> <span class="hljs-string">cn=module,cn=config</span><span class="hljs-attr">objectClass:</span> <span class="hljs-string">olcModuleList</span><span class="hljs-attr">cn:</span> <span class="hljs-string">module</span> <span class="hljs-attr">olcModuleLoad:</span> <span class="hljs-string">memberof.la</span><span class="hljs-attr">olcModulepath:</span> <span class="hljs-string">/usr/lib64/openldap</span><span class="hljs-comment">#ldap库路径与操作系统版本是相关的，此处是64位操作系统。</span></code></pre><ol start="2"><li>新增用户支持 memberof 配置。</li></ol><pre><code class="hljs yaml"><span class="hljs-string">vim</span> <span class="hljs-number">2</span><span class="hljs-string">-use-memberof.ldif</span><span class="hljs-attr">dn:</span> <span class="hljs-string">olcOverlay=memberof,olcDatabase=&#123;2&#125;hdb,cn=config</span><span class="hljs-attr">objectClass:</span> <span class="hljs-string">olcConfig</span><span class="hljs-attr">objectClass:</span> <span class="hljs-string">olcMemberOf</span><span class="hljs-attr">objectClass:</span> <span class="hljs-string">olcOverlayConfig</span><span class="hljs-attr">objectClass:</span> <span class="hljs-string">top</span><span class="hljs-attr">olcOverlay:</span> <span class="hljs-string">memberof</span></code></pre><ol start="3"><li>导入相关配置。</li></ol><pre><code class="hljs sh">ldapadd -Y EXTERNAL -H ldapi:/// -f 1-chrootpw.ldifldapadd -Y EXTERNAL -H ldapi:/// -f 2-chdomain.ldifldapadd -Y EXTERNAL -H ldapi:/// -f 3-load-memberof.ldifldapadd -Y EXTERNAL -H ldapi:/// -f 4-use-memberof.ldif</code></pre><ol start="4"><li>查看当前 dn 下包含 cn=config 配置列表。</li></ol><pre><code class="hljs sh">ldapsearch -Q -LLL -Y EXTERNAL -H ldapi:/// -b cn=config dn</code></pre><ol start="5"><li>查看用户的 memberof 信息。</li></ol><pre><code class="hljs sh">ldapsearch -LL -Y EXTERNAL -H ldapi:/// <span class="hljs-string">&quot;(uid=xxxxxx)&quot;</span> -b dc=xxx,dc=com dn memberof</code></pre><h2 id="开启日志"><a href="#开启日志" class="headerlink" title="开启日志"></a>开启日志</h2><div class="tag-plugin timeline"><div class="timenode" item="1"><div class="header"><p>查看现在的日志配置</p></div><div class="body fs14"><p>[root@slave3] ~$ cat /etc/openldap/slapd.d/cn=config.ldif |grep olcLogLevel<br>state</p></div></div><div class="timenode" item="2"><div class="header"><p>必须先创建日志文件，并调整权限，再修改 rsyslog.conf</p></div><div class="body fs14"><p>mkdir -p /var/log/slapd</p><p>touch /var/log/slapd/slapd.log</p><p>chown ldap:ldap /var/log/slapd/</p><p>echo “local4.* /var/log/slapd/slapd.log” &gt;&gt; /etc/rsyslog.conf</p></div></div><div class="timenode" item="3"><div class="header"><p>重启使其生效</p></div><div class="body fs14"><p><code>systemctl restart rsyslog</code></p></div></div><div class="timenode" item="4"><div class="header"><p>修改数数据库配置文件</p></div><div class="body fs14"><p>[root@test1] ~$ cat log.ldif<br>dn: cn=config<br>changetype: modify<br>add: olcLogLevel<br>olcLogLevel: 32</p><p>[root@test1] ~$ ldapmodify -Y EXTERNAL -H ldapi:/// -f log.ldif</p></div></div><div class="timenode" item="5"><div class="header"><p>最好进行日志切割配置，防止文件过大，不便排查故障</p></div><div class="body fs14"><p><code>vi /etc/logrotate.d/ldap</code></p><p>/var/log/slapd/slapd.log{<br>    daily          # 每天轮询一次<br>    rotate  5      # 保存5个历史日志文件，超过的删除<br>    size 100M<br>    copytruncate   # 复制源日志内容后，清空文件，而不是创建新文件<br>    dateext        # 切割文件时，文件名带有日期<br>    missingok      # 如果指定的目录不存在，会报错，此选项用来抑制报错<br>}</p></div></div></div><div class="tag-plugin note" color="orange"><div class="body"><p>如果你是使用旧版修改配置文件的方式，如下启用日志功能</p></div></div><div class="tag-plugin timeline"><div class="timenode" item="1"><div class="header"><p>修改 <code>slapd.conf</code></p></div><div class="body fs14"><p>[root@backup2] /etc/openldap$ vim slapd.conf</p><p>#末尾添加一行<br>loglevel        -1</p></div></div><div class="timenode" item="2"><div class="header"><p>修改 rsyslog.conf，并重启</p></div><div class="body fs14"><p>[root@backup2] /etc/openldap$ vim /etc/rsyslog.conf</p><p>#末尾添加如下一行：<br>local4.*         /var/log/slapd.log</p><p>[root@backup2] /etc/openldap$ systemctl restart rsyslog</p></div></div><div class="timenode" item="3"><div class="header"><p>生成配置</p></div><div class="body fs14"><p>[root@backup2] /etc/openldap$ rm -rf /etc/openldap/slapd.d/*<br>[root@backup2] /etc/openldap$ slaptest -f /etc/openldap/slapd.conf -F /etc/openldap/slapd.d/<br>[root@backup2] /etc/openldap$ systemctl start slapd.service<br>123</p></div></div></div><div class="tag-plugin note" color="green"><div class="title"><strong>来查看日志</strong></div><div class="body"><p>通过 <code>tailf /var/log/slapd.log</code> 来查看日志</p></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;备份与恢复&quot;&gt;&lt;a href=&quot;#备份与恢复&quot; class=&quot;headerlink&quot; title=&quot;备份与恢复&quot;&gt;&lt;/a&gt;备份与恢复&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;主要介绍如何备份 OpenLDAP 的配置目录和数据目录，并将其恢复到另一个 OpenLD</summary>
      
    
    
    
    <category term="折腾不止" scheme="https://liei.cc/blog/categories/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2/"/>
    
    
    <category term="OpenLDAP" scheme="https://liei.cc/blog/tags/openldap/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 控制器的进化之旅</title>
    <link href="https://liei.cc/2020/kubernetes-operator.html"/>
    <id>https://liei.cc/2020/kubernetes-operator.html</id>
    <published>2020-07-25T07:15:15.000Z</published>
    <updated>2020-07-25T07:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我是一堆 Kubernetes 控制器。</p><p>你可能会疑惑为什么是一堆，因为我不是一个人，我只是众多控制器中的一员，你也可以把我看成是众多控制器的集合。我的职责就是监控集群内资源的实际状态，一旦发现其与期望的状态不相符，就采取行动使其符合期望状态。</p><p>想当初，Kubernetes 老大哥创造我时，只是打算让我用<strong>控制循环</strong>简单维护下资源的状态。但我后来的发展，远远超出了他的想象。</p></blockquote><span id="more"></span><h2 id="1-控制循环"><a href="#1-控制循环" class="headerlink" title="1. 控制循环"></a>1. 控制循环</h2><p>所谓控制循环就是一个用来调节系统状态的周期性操作，在 Kubernetes 中也叫<strong>调谐循环</strong>（Reconcile Loop）。我的手下控制着很多种不同类型的资源，比如 Pod，Deployment，Service 等等。就拿 <code>Deployment</code> 来说吧，我的控制循环主要分为三步：</p><ol><li>从 <code>API Server</code> 中获取到所有属于该 Deployment 的 Pod，然后统计一下它们的数量，即它们的实际状态。</li><li>检查 Deployment 的 <code>Replicas</code> 字段，看看期望状态是多少个 Pod。</li><li>将这两个状态做比较，如果期望状态的 Pod 数量比实际状态多，就创建新 Pod，多几个就创建几个新的；如果期望状态的 Pod 数量比实际状态少，就删除旧 Pod，少几个就删除几个旧的。</li></ol><p>然而好景不长，我收到了 Kubernetes 掌门人（看大门的） <code>API Server</code> 的抱怨：“你访问我的次数太频繁了，非常消耗我的资源，我连上厕所的时间都没有了！”</p><p>我仔细一想，当前的控制循环模式确实有这个缺陷 —— 访问 <code>API Server</code> 的次数太频繁了，容易被老大反感。</p><p>所以我决定，找一个小弟。</p><h2 id="2-Informer"><a href="#2-Informer" class="headerlink" title="2. Informer"></a>2. Informer</h2><p>这次我招的小弟叫 <code>Informer</code>，它分担一部分我的任务，具体的做法是这样的：由 <code>Informer</code> 代替我去访问 API Server，而我不管是查状态还是对资源进行伸缩都和 Informer 进行交接。而且 Informer 不需要每次都去访问 API Server，它只要在初始化的时候通过 <code>LIST API</code> 获取所有资源的最新状态，然后再通过 <code>WATCH API</code> 去监听这些资源状态的变化，整个过程被称作 <code>ListAndWatch</code>。</p><p>而 Informer 也不傻，它也有一个助手叫 <code>Reflector</code>，上面所说的 <code>ListAndWatch</code> 事实上是由 Reflector 一手操办的。</p><p>这一次，<code>API Server</code> 的压力大大减轻了，因为 Reflector 大部分时间都在 <code>WATCH</code>，并没有通过 LIST 获取所有状态，这使 <code>API Server</code> 的压力大大减少。我想这次掌门人应该不会再批评我了吧。</p><p>然而没过几天，掌门人又找我谈话了：“你的手下每次来 WATCH 我，都要 WATCH 所有兄弟的状态，依然很消耗我的资源啊！我就纳闷了，你一次搞这么多兄弟，你虎啊？”</p><p>我一想有道理啊，没必要每次都 WATCH 所有兄弟的状态，于是告诉 Informer：“以后再去 API Server 那里 WATCH 状态的时候，只查 WATCH 特定资源的状态，不要一股脑儿全 WATCH。“</p><p>Informer 再把这个决策告诉 Reflector，事情就这么愉快地决定了。</p><p>本以为这次我会得到掌门人的夸奖，可没过几天安稳日子，它又来找我诉苦了：“兄弟，虽然你减轻了我的精神压力，但我的财力有限啊，如果每个控制器都招一个小弟，那我得多发多少人的工资啊，你想想办法。”</p><h2 id="3-SharedInformer"><a href="#3-SharedInformer" class="headerlink" title="3. SharedInformer"></a>3. SharedInformer</h2><p>经过和其他控制器的讨论，我们决定这么做：所有控制器联合起来作为一个整体来分配 <code>Informer</code>，针对每个（受多个控制器管理的）资源招一个 Informer 小弟，我们称之为 <code>SharedInformer</code>。你们可以理解为共享 Informer，因为有很多资源是受多个控制器管理的，比如 Pod 同时受 <code>Deployment</code> 和 <code>StatefulSet</code> 管理。这样当多个控制器同时想查 Pod 的状态时，只需要访问一个 Informer 就行了。</p><p>但这又引来了新的问题，<code>SharedInformer</code> 无法同时给多个控制器提供信息，这就需要每个控制器自己排队和重试。</p><p>为了配合控制器更好地实现排队和重试，<code>SharedInformer</code> 搞了一个 <code>Delta FIFO Queue</code>（增量先进先出队列），每当资源被修改时，它的助手 <code>Reflector</code> 就会收到事件通知，并将对应的事件放入 <code>Delta FIFO Queue</code> 中。与此同时，<code>SharedInformer</code> 会不断从 <code>Delta FIFO Queue</code> 中读取事件，然后更新本地缓存的状态。</p><p>这还不行，<code>SharedInformer</code> 除了更新本地缓存之外，还要想办法将数据同步给各个控制器，为了解决这个问题，它又搞了个工作队列（Workqueue），一旦有资源被添加、修改或删除，就会将相应的事件加入到工作队列中。所有的控制器排队进行读取，一旦某个控制器发现这个事件与自己相关，就执行相应的操作。如果操作失败，就将该事件放回队列，等下次排到自己再试一次。如果操作成功，就将该事件从队列中删除。</p><p>现在这个工作模式得到了大家的一致好评。虽然单个 <code>SharedInformer</code> 的工作量增加了，但 Informer 的数量大大减少了，老大可以把省下来的资金拿出一小部分给 <code>SharedInformer</code> 涨工资啊，这样大家都很开心。</p><h2 id="4-CRD"><a href="#4-CRD" class="headerlink" title="4. CRD"></a>4. CRD</h2><p>全民 Kubernetes 时代到了。</p><p>随着容器及其编排技术的普及，使用 Kubernetes 的用户大量增长，用户已经不满足 Kubernetes 自带的那些资源（Pod，Node，Service）了，大家都希望能根据具体的业务创建特定的资源，并且对这些资源的状态维护还要遵循上面所说的那一套控制循环机制。</p><p>幸好最近掌门人做了一次升级，新增了一个插件叫 <code>CRD（Custom Resource Definition）</code>，创建一个全新的资源实例，只需要经过以下两步：</p><ol><li>创建一个 CRD 资源（没错，CRD 也是一种资源类型），其中定义” 自定义资源 “的 <strong>API 组</strong>、<strong>API 版本</strong>和<strong>资源类型</strong>。这样就会向 API Server 注册该资源类型的 API。</li><li>指定上面定义的 API 组 和 API 版本，创建自定义资源。</li></ol><p>当然，中间还要加入一些代码让 Kubernetes 认识自定义资源的各种参数。</p><p>到这一步就基本上完成了自定义资源的创建，但 Kubernetes 并不知道该资源所对应的业务逻辑，比如你的自定义资源是宿主机，那么对应的业务逻辑就是创建一台真正的宿主机出来。那么怎样实现它的业务逻辑呢？</p><h2 id="5-自定义控制器"><a href="#5-自定义控制器" class="headerlink" title="5. 自定义控制器"></a>5. 自定义控制器</h2><p><code>Controller Manager</code> 见多识广，说：” 这里的每个控制器都是我的一部分，当初创造你们是因为你们都属于通用的控制器，大家都能用得上。而自定义资源需要根据具体的业务来实现，我们不可能知道每个用户的具体业务是啥，自己一拍脑袋想出来的自定义资源，用户也不一定用得上。我们可以让用户自己编写自定义控制器，你们把之前使用的控制循环和 Informer 这些编码模式总结一下，然后提供给用户，让他们按照同样的方法编写自己的控制器。“</p><p>Deployment 控制器一惊，要把自己的秘密告诉别人？那别人把自己取代了咋办？赶忙问道：” 那将来我岂不是很危险，没有存在的余地了？“</p><p><code>Controller Manager</code> 赶忙解释道：” 不用担心，虽然用户可以编写自定义控制器，但无论他们玩出什么花样，只要他们的业务跑在 Kubernetes 平台上，就免不了要跑容器，最后还是会来求你们帮忙的，你要知道，控制器是可以层层递进的，他们只不过是在你外面套了一层，最后还是要回到你这里，请求你帮忙控制 Pod。“</p><p>这下大家都不慌了，决定就把自定义控制器这件事情交给用户自己去处理，将选择权留给用户。</p><h2 id="6-Operator"><a href="#6-Operator" class="headerlink" title="6. Operator"></a>6. Operator</h2><p>用户自从获得了编写自定义控制器的权力之后，非常开心，有的用户（CoreOS）为了方便大家控制有状态应用，开发出了一种特定的控制器模型叫 <code>Operator</code>，并开始在社区内推广，得到了大家的一致好评。不可否认，<code>Operator</code> 这种模式是很聪明的，它把需要特定领域知识的应用单独写一个 Operator 控制器，将这种应用特定的操作知识编写到软件中，使其可以利用 Kubernetes 强大的抽象能力，达到正确运行和管理应用的目的。</p><p>以 <code>ETCD Operator</code> 为例，假如你想手动扩展一个 ETCD 集群，一般的做法是：</p><ol><li>使用 ETCD 管理工具添加一个新成员。</li><li>为这个成员所在的节点生成对应的启动参数，并启动它。</li></ol><p>而 ETCD Operator 将这些特定于 etcd 的操作手法编写到了它的控制循环中，你只需要通过修改自定义资源声明集群期望的成员数量，剩下的事情交给 Operator 就好了。</p><p>本以为这是一个皆大欢喜的方案，但没过多久，就有开发 Operator 的小哥来抱怨了：” 我们有很多开发的小伙伴都是不懂运维那一套的，什么高可用、容灾根本不懂啊，现在让我们将运维的操作知识编写到软件中，臣妾做不到啊。。“</p><p>这确实是个问题，这样一来就把开发和运维的工作都塞到了开发手里，既懂开发又懂运维的可不多啊，为了照顾大家，还得继续想办法把开发和运维的工作拆分开来。</p><h2 id="7-OAM"><a href="#7-OAM" class="headerlink" title="7. OAM"></a>7. OAM</h2><p>这时候阿里和微软发力了，他们联合发布了一个开放应用模型，叫 <a href="https://cloudblogs.microsoft.com/opensource/2019/10/16/announcing-open-application-model/">Open Application Model </a>（OAM）。这个模型就是为了解决上面提到的问题，将开发和运维的职责解耦，不同的角色履行不同的职责，并形成一个统一的规范，如下图所示：</p><p><img src="https://hugo-picture.oss-cn-beijing.aliyuncs.com/images/20200223122350.png" alt="img"></p><p>这个规范告诉我们：</p><ul><li>开发人员负责描述组件的功能，如何配置组件，以及运行需要多少资源</li><li>运维人员负责将相关组件组合成一个应用，并配置运行时参数和运维支撑能力，比如是否需要监控，是否需要弹性伸缩。</li><li>基础设施工程师负责建立和维护应用的运行时环境（如底层系统）。</li></ul><p>其中每一个团队负责的事情都用对应的 CRD 来配置。</p><p>这样一来，开发和运维人员的职责就被区分开来了，简化了应用的组合和运维。它将应用的配置和运维特征（如自动伸缩、流量监控）进行解耦，然后通过建模构成一个整体，避免了 Operator 这种模型带来的大量冗余。</p><p>自从用上了这个模型之后，运维和开发小哥表示现在他们的关系很融洽，没事还能一起出去喝两杯。</p><h2 id="文章转自"><a href="#文章转自" class="headerlink" title="文章转自"></a>文章转自</h2><div class="tag-plugin link dis-select"><a class="link-card rich" title="Kubernetes控制器的进化之旅" href="https://fuckcloudnative.io/posts/controllers-confession/" target="_blank" rel="external nofollow noopener noreferrer"><div class="top"><div class="lazy img" data-bg="https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/link/8f277b4ee0ecd.svg"></div><span class="desc fs12">https://fuckcloudnative.io/posts/controllers-confession/</span></div><div class="bottom"><span class="title">Kubernetes控制器的进化之旅</span><span class="desc fs12">https://fuckcloudnative.io/posts/controllers-confession/</span></div></a></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;我是一堆 Kubernetes 控制器。&lt;/p&gt;
&lt;p&gt;你可能会疑惑为什么是一堆，因为我不是一个人，我只是众多控制器中的一员，你也可以把我看成是众多控制器的集合。我的职责就是监控集群内资源的实际状态，一旦发现其与期望的状态不相符，就采取行动使其符合期望状态。&lt;/p&gt;
&lt;p&gt;想当初，Kubernetes 老大哥创造我时，只是打算让我用&lt;strong&gt;控制循环&lt;/strong&gt;简单维护下资源的状态。但我后来的发展，远远超出了他的想象。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="技术加油站" scheme="https://liei.cc/blog/categories/%E6%8A%80%E6%9C%AF%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    
    
    <category term="Cloud Navite" scheme="https://liei.cc/blog/tags/cloud-navite/"/>
    
    <category term="Kubernetes" scheme="https://liei.cc/blog/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>OpenLDAP 快速落地实践-部署配置</title>
    <link href="https://liei.cc/2020/openldap-install-config.html"/>
    <id>https://liei.cc/2020/openldap-install-config.html</id>
    <published>2020-07-20T07:15:15.000Z</published>
    <updated>2020-07-20T07:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h2><p>本文中相关操作系统及依赖包的版本如下：</p><ul><li>centos-release-7-4.1708.el7.centos.x86_64</li><li>openldap-clients-2.4.44-5.el7.x86_64：包含客户端程序，用来访问和修改 OpenLDAP 目录</li><li>openldap-servers-2.4.44-5.el7.x86_64：包含主 LDAP 服务器 slapd 和同步服务器 slurpd 服务器、迁移脚本和相关文件</li></ul><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><p><strong>第一步，需要切换到 root 账号来安装 OpenLDAP 相关程序包，并启动服务：</strong></p><pre><code class="hljs bash">$ yum install -y openldap-servers openldap-clients$ cp /usr/share/openldap-servers/DB_CONFIG.example /var/lib/ldap/DB_CONFIG$ chown ldap. /var/lib/ldap/DB_CONFIG$ systemctl <span class="hljs-built_in">enable</span> slapd$ systemctl start slapd</code></pre><p><strong>第二步，我们使用 <code>slappasswd</code> 命令来生成一个密码，并使用 LDIF（LDAP 数据交换格式）文件将其导入到 LDAP 中来配置管理员密码：</strong></p><pre><code class="hljs bash">$ slappasswdNew password:Re-enter new password:&#123;SSHA&#125;KS/bFZ8KTmO56khHjJvM97l7zivH1MwG$ vim chrootpw.ldif<span class="hljs-comment"># specify the password generated above for &quot;olcRootPW&quot; section</span>dn: olcDatabase=&#123;0&#125;config,cn=configchangetype: modifyadd: olcRootPWolcRootPW: &#123;SSHA&#125;KS/bFZ8KTmO56khHjJvM97l7zivH1MwG$ ldapadd -Y EXTERNAL -H ldapi:/// -f chrootpw.ldif</code></pre><p><strong>第三步，我们需要向 LDAP 中导入一些基本的 Schema。这些 Schema 文件位于 <code>/etc/openldap/schema/</code> 目录中，定义了我们以后创建的条目可以使用哪些属性</strong>：</p><pre><code class="hljs bash">$ ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/core.ldif$ ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/cosine.ldif$ ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/nis.ldif$ ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/inetorgperson.ldif</code></pre><p><strong>第四步，我们需要配置 LDAP 的顶级域（以 <code>dc=leeif,dc=me</code> 为例）及其管理域：</strong></p><pre><code class="hljs bash">$ slappasswdNew password:Re-enter new password:&#123;SSHA&#125;z/rsbmAjVtLlWeUB0xS5itLPI0VA1akD$ vim chdomain.ldif<span class="hljs-comment"># replace to your own domain name for &quot;dc=***,dc=***&quot; section</span><span class="hljs-comment"># specify the password generated above for &quot;olcRootPW&quot; section</span>dn: olcDatabase=&#123;1&#125;monitor,cn=configchangetype: modifyreplace: olcAccessolcAccess: &#123;0&#125;to * by dn.base=<span class="hljs-string">&quot;gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth&quot;</span>  <span class="hljs-built_in">read</span> by dn.base=<span class="hljs-string">&quot;cn=admin,dc=leeif,dc=me&quot;</span> <span class="hljs-built_in">read</span> by * nonedn: olcDatabase=&#123;2&#125;mdb,cn=configchangetype: modifyreplace: olcSuffixolcSuffix: dc=leeif,dc=medn: olcDatabase=&#123;2&#125;mdb,cn=configchangetype: modifyreplace: olcRootDNolcRootDN: cn=admin,dc=leeif,dc=medn: olcDatabase=&#123;2&#125;mdb,cn=configchangetype: modifyadd: olcRootPWolcRootPW: &#123;SSHA&#125;z/rsbmAjVtLlWeUB0xS5itLPI0VA1akDdn: olcDatabase=&#123;2&#125;mdb,cn=configchangetype: modifyadd: olcAccessolcAccess: &#123;0&#125;to attrs=userPassword,shadowLastChange by  dn=<span class="hljs-string">&quot;cn=admin,dc=leeif,dc=me&quot;</span> write by anonymous auth by self write by * noneolcAccess: &#123;1&#125;to dn.base=<span class="hljs-string">&quot;&quot;</span> by * <span class="hljs-built_in">read</span>olcAccess: &#123;2&#125;to * by dn=<span class="hljs-string">&quot;cn=admin,dc=leeif,dc=me&quot;</span> write by * <span class="hljs-built_in">read</span>$ ldapmodify -Y EXTERNAL -H ldapi:/// -f chdomain.ldif</code></pre><p><strong>第五步，在上述基础上，我们来创建一个叫做 leeif News Agency 的组织，并在其下创建一个 Manager 的组织角色（该角色内的用户具有管理整个 LDAP 的权限）和 People 和 Group 两个组织单元：</strong></p><pre><code class="hljs bash">$ vim basedomain.ldif<span class="hljs-comment"># replace to your own domain name for &quot;dc=***,dc=***&quot; section</span>dn: dc=leeif,dc=meobjectClass: topobjectClass: dcObjectobjectclass: organizationo: leeif.IOdc: leeifdn: cn=admin,dc=leeif,dc=meobjectClass: organizationalRolecn: Managerdn: ou=people,dc=leeif,dc=meobjectClass: organizationalUnitou: peopledn: ou=group,dc=leeif,dc=meobjectClass: organizationalUnitou: group$ ldapadd -x -D cn=admin,dc=leeif,dc=me -W -f basedomain.ldif</code></pre><p>通过以上的所有步骤，我们就设置好了一个 LDAP 目录树：其中基准 dn <code>dc=leeif,dc=me</code> 是该树的根节点，其下有一个管理域 <code>cn=admin,dc=leeif,dc=me</code> 和两个组织单元 <code>ou=people,dc=leeif,dc=me</code> 及 <code>ou=group,dc=leeif,dc=me</code>。</p><p>接下来，我们来创建一个叫作 Ada Catherine 的员工并将其分配到 Secretary 组来验证上述配置是否生效。</p><pre><code class="hljs bash">$ slappasswdNew password:Re-enter new password:&#123;SSHA&#125;HTGqAd4p6fOOIVHm7VZYUSorWGfnrqAA$ vim ldapuser.ldif<span class="hljs-comment"># create new</span><span class="hljs-comment"># replace to your own domain name for &quot;dc=***,dc=***&quot; section</span>dn: uid=ada,ou=people,dc=leeif,dc=meobjectClass: inetOrgPersonobjectClass: posixAccountobjectClass: shadowAccountuid: adacn: Ada Catherinesn: CatherineuserPassword: &#123;SSHA&#125;HTGqAd4p6fOOIVHm7VZYUSorWGfnrqAAloginShell: /bin/bashuidNumber: 1000gidNumber: 1000homeDirectory: /home/users/adadn: cn=Secretary,ou=group,dc=leeif,dc=meobjectClass: posixGroupcn: SecretarygidNumber: 1000memberUid: ada<span class="hljs-comment"># ldapadd -x -D cn=admin,dc=leeif,dc=me -W -f ldapuser.ldif</span>Enter LDAP Password:adding new entry <span class="hljs-string">&quot;uid=ada,ou=People,dc=leeif,dc=org&quot;</span>adding new entry <span class="hljs-string">&quot;cn=Secretary,ou=Group,dc=leeif,dc=org&quot;</span></code></pre><p>我们也可以使用 <code>ldapsearch</code> 命令来查看 LDAP 目录服务中的所有条目信息：</p><pre><code class="hljs bash">$ ldapsearch -x -b <span class="hljs-string">&quot;dc=leeif,dc=me&quot;</span> -H ldap://127.0.0.1<span class="hljs-comment"># extended LDIF</span><span class="hljs-comment">#</span><span class="hljs-comment"># LDAPv3</span><span class="hljs-comment"># base &lt;dc=leeif,dc=me&gt; with scope subtree</span><span class="hljs-comment"># filter: (objectclass=*)</span><span class="hljs-comment"># requesting: ALL</span><span class="hljs-comment">#</span><span class="hljs-comment"># leeif.org</span>dn: dc=leeif,dc=meobjectClass: topobjectClass: dcObjectobjectClass: organizationo: leeif News Agencydc: leeif...</code></pre><p>如果要删除一个条目，可以按下面的命令操作：</p><pre><code class="hljs bash">$ ldapdelete -x -W -D <span class="hljs-string">&#x27;cn=admin,dc=leeif,dc=me&#x27;</span> <span class="hljs-string">&quot;uid=ada,ou=People,dc=leeif,dc=me&quot;</span></code></pre><h2 id="常用命令记录"><a href="#常用命令记录" class="headerlink" title="常用命令记录"></a>常用命令记录</h2><pre><code class="hljs bash">(&amp;(&amp;(objectClass=inetOrgPerson)))mkdir /etc/yum.repos.d/backupmv /etc/yum.repos.d/* /etc/yum.repos.d/backup/curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repoyum -y install openldap-servers openldap-clients<span class="hljs-comment"># yum reinstall --downloadonly --downloaddir=./openldap/ openldap-servers openldap-clients</span>mv slapd.d slapd.d.baksudo systemctl stop slapd &amp;&amp; sudo rm -rf slapd.d &amp;&amp; sudo mkdir slapd.dsudo slaptest -f /etc/openldap/slapd.conf -F /etc/openldap/slapd.dsudo chown -R ldap:ldap slapd.d  &amp;&amp; sudo systemctl start slapdsystemctl stop slapd &amp;&amp; rm -rf slapd.d &amp;&amp; mkdir slapd.dslaptest -f /etc/openldap/slapd.conf -F /etc/openldap/slapd.dchown -R ldap:ldap slapd.d  &amp;&amp; systemctl start slapdservice slapd stop &amp;&amp; rm -rf slapd.d &amp;&amp; mkdir slapd.dslaptest -f /etc/openldap/slapd.conf -F /etc/openldap/slapd.dchown -R ldap:ldap slapd.d  &amp;&amp; service slapd startrm -rf /var/lib/ldap &amp;&amp; mkdir /var/lib/ldapcp /usr/share/openldap-servers/slapd.ldif /etc/openldap/cp /usr/share/openldap-servers/DB_CONFIG.example /var/lib/ldap/DB_CONFIGchown ldap. /var/lib/ldap/DB_CONFIGchown -R ldap:ldap slapd.d chown -R ldap:ldap /var/lib/ldap/*<span class="hljs-comment"># 方案一</span>vim /etc/openldap/slapd.ldif  <span class="hljs-comment">##修改后的初始化ldif文件</span>slapadd -n 0 -F slapd.d -l slapd.ldif   <span class="hljs-comment">##生成配置数据库信息</span><span class="hljs-comment"># 方案二</span>vi /etc/openldap/slapd.confslaptest -f /etc/openldap/slapd.conf -F /etc/openldap/slapd.d<span class="hljs-comment"># systemctl start slapd</span><span class="hljs-comment"># systemctl enable slapd</span><span class="hljs-comment"># systemctl status slapd</span></code></pre><h2 id="slapd-conf-文件配置"><a href="#slapd-conf-文件配置" class="headerlink" title="slapd.conf 文件配置"></a>slapd.conf 文件配置</h2><pre><code class="hljs bash">pidfile /var/run/openldap/slapd.pidargsfile /var/run/openldap/slapd.argsinclude /etc/openldap/schema/core.schemainclude /etc/openldap/schema/collective.schemainclude /etc/openldap/schema/corba.schemainclude /etc/openldap/schema/cosine.schemainclude /etc/openldap/schema/duaconf.schemainclude /etc/openldap/schema/dyngroup.schemainclude /etc/openldap/schema/inetorgperson.schemainclude /etc/openldap/schema/java.schemainclude /etc/openldap/schema/misc.schemainclude /etc/openldap/schema/nis.schemainclude /etc/openldap/schema/openldap.schemainclude /etc/openldap/schema/pmi.schemainclude /etc/openldap/schema/ppolicy.schemamodulepath /usr/lib64/openldapmoduleload memberof.lamoduleload back_ldap.lamoduleload back_relay.lamoduleload pcache.lamoduleload ppolicy.lamoduleload syncprov.lamoduleload rwm.laloglevel 256<span class="hljs-comment"># before any database</span>overlay rwmrwm-rewriteEngine onrwm-rewriteContext bindDN<span class="hljs-comment"># rwm-rewriteRule &quot;(.+,)?dc=leeif,dc=me$&quot; &quot;$1dc=auth&quot; &quot;:@&quot;</span>rwm-rewriteRule <span class="hljs-string">&quot;(^uid=.+,)(.+,)?dc=leeif,dc=me$&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1dc</span>=auth&quot;</span> <span class="hljs-string">&quot;:@&quot;</span>database    configaccess  to *        by dn.base=<span class="hljs-string">&quot;gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth&quot;</span> manage        by * nonedatabase    monitoraccess  to dn.base=<span class="hljs-string">&quot;dc=ldapproxy,dc=com&quot;</span>        by ssf=256 group.exact=<span class="hljs-string">&quot;cn=admin,dc=ldapproxy,dc=com&quot;</span> <span class="hljs-built_in">read</span>        by * nonedatabase    hdbsuffix      <span class="hljs-string">&quot;dc=ldapproxy,dc=com&quot;</span>rootdn      <span class="hljs-string">&quot;cn=admin,dc=ldapproxy,dc=com&quot;</span>rootpw      &#123;SSHA&#125;passworddirectory   /var/lib/ldap<span class="hljs-comment"># Database LDAP for OpenLDAP </span>database    ldap<span class="hljs-built_in">readonly</span>    yessuffix      <span class="hljs-string">&quot;dc=leeif,dc=me&quot;</span>uri         ldap://127.0.0.1:389idassert-bind bindmethod=simple   binddn=<span class="hljs-string">&quot;cn=admin,dc=leeif,dc=me&quot;</span>   credentials=<span class="hljs-string">&quot;zto.com&quot;</span>   mode=none   flags=non-prescriptiveidassert-authzFrom <span class="hljs-string">&quot;dn.exact:cn=admin,dc=ldapproxy,dc=com&quot;</span><span class="hljs-comment"># Database LDAP for LDAP-Auth</span>database    ldap<span class="hljs-built_in">readonly</span>    yessuffix      <span class="hljs-string">&quot;dc=auth&quot;</span>uri         ldap://127.0.0.1:10389</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;下载依赖&quot;&gt;&lt;a href=&quot;#下载依赖&quot; class=&quot;headerlink&quot; title=&quot;下载依赖&quot;&gt;&lt;/a&gt;下载依赖&lt;/h2&gt;&lt;p&gt;本文中相关操作系统及依赖包的版本如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;centos-release-7-4.1708.el7.c</summary>
      
    
    
    
    <category term="折腾不止" scheme="https://liei.cc/blog/categories/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2/"/>
    
    
    <category term="OpenLDAP" scheme="https://liei.cc/blog/tags/openldap/"/>
    
  </entry>
  
  <entry>
    <title>OpenLDAP 快速落地实践-基本介绍</title>
    <link href="https://liei.cc/2020/openldap-getting-started.html"/>
    <id>https://liei.cc/2020/openldap-getting-started.html</id>
    <published>2020-07-15T07:15:15.000Z</published>
    <updated>2020-07-15T07:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景需求"><a href="#场景需求" class="headerlink" title="场景需求"></a>场景需求</h2><p><img src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/2020/20200809201834.png" alt="openldap-architecture"></p><div class="tag-plugin note" color="orange"><div class="title"><strong>需求</strong></div><div class="body"><p>当公司体量较大，内部有多个系统，如果每个平台都需要维护一个用户管理体系，那么如果一个员工拥有 N 个平台权限离职及常规权限变更，对于的管理无疑也是一个挑战，也无法做到精细化权限管理。比如每次新进或离职一位同事，我们这边 OPS 运维组的小伙伴们，都要在每个系统上去添加用户，搞得小伙伴们很不爽。</p></div></div><p>简单说一下 OPENLDAP 对运维管理的价值，支撑企业技术发展比如 <code>GIT、 ZABBIX、 YAPI、 JUMPSERVER、 OA</code> 等大大小小系统，乃至 Windows，Linux 系统的认证登录。</p><span id="more"></span><p>通过 LDAP 技术我们可以实现多平台账号集中管理，权限灵活控制，密码强度及其有效期的约束，将用户管理与各个平台解耦，最终实现一次修改 N 处生效。</p><h2 id="LDAP-简介"><a href="#LDAP-简介" class="headerlink" title="LDAP 简介"></a>LDAP 简介</h2><p><code>LDAP</code>（轻量级目录访问协议，<code>Lightweight Directory Access Protocol</code>) 是实现提供被称为目录服务的信息服务。目录服务是一种特殊的数据库系统，其专门针对读取，浏览和搜索操作进行了特定的优化。目录一般用来包含描述性的，基于属性的信息并支持精细复杂的过滤能力。目录一般不支持通用数据库针对大量更新操作操作需要的复杂的事务管理或回卷策略。而目录服务的更新则一般都非常简单。这种目录可以存储包括个人信息、web 链结、jpeg 图像等各种信息。为了访问存储在目录中的信息，就需要使用运行在 TCP/IP 之上的访问协议 —LDAP。</p><p>LDAP 目录中的信息是是按照树型结构组织，具体信息存储在条目 (entry) 的数据结构中。条目相当于关系数据库中表的记录；条目是具有区别名 <code>DN</code> （Distinguished Name）的属性（Attribute），DN 是用来引用条目的，DN 相当于关系数据库表中的关键字（Primary Key）。属性由类型（Type）和一个或多个值（Values）组成，相当于关系数据库中的字段（Field）由字段名和数据类型组成，只是为了方便检索的需要，LDAP 中的 Type 可以有多个 Value，而不是关系数据库中为降低数据的冗余性要求实现的各个域必须是不相关的。LDAP 中条目的组织一般按照地理位置和组织关系进行组织，非常的直观。LDAP 把数据存放在文件中，为提高效率可以使用基于索引的文件数据库，而不是关系数据库。类型的一个例子就是 mail，其值将是一个电子邮件地址。</p><h2 id="OpenLADP-简介"><a href="#OpenLADP-简介" class="headerlink" title="OpenLADP 简介"></a>OpenLADP 简介</h2><p>LDAP 具有两个标准，分别是 X.500 和 LDAP。OpenLDAP 是基于 X.500 标准的，而且去除了 X.500 复杂的功能并且可以根据自我需求定制额外扩展功能，但与 X.500 也有不同之处，例如 OpenLDAP 支持 TCP/IP 协议等。</p><p>OpenLDAP 可以直接运行在更简单和更通用的 TCP/IP 或其他可靠的传输协议层上，避免了在 OSI 会话层和表示层的开销，使连接的建立和包的处理更简单、更快，对于互联网和企业网应用更理想。</p><p>OpenLDAP 目录中的信息是以树状的层次结构来存储数据（这很类同于 DNS），最顶层即根部称作 “基准 DN”，形如 “dc=mydomain,dc=org” 或者 “o=mydomain.org”，前一种方式更为灵活也是 Windows AD 中使用的方式。在根目录的下面有很多的文件和目录，为了把这些大量的数据从逻辑上分开，OpenLDAP 像其它的目录服务协议一样使用 <code>OU</code>（<code>Organization Unit</code>，组织单元），可以用来表示公司内部机构，如部门等，也可以用来表示设备、人员等。同时 OU 还可以有子 OU，用来表示更为细致的分类。</p><p>OpenLDAP 中每一条记录都有一个唯一的区别于其它记录的名字 <code>DN</code>（<code>Distinguished Name</code>）, 其处在 “叶子” 位置的部分称作 RDN (用户条目的相对标识名)。如 dn:cn=tom,ou=animals,dc=ilanni,dc=com 中 cn 即为 RDN，而 RDN 在一个 OU 中必须是唯一的。</p><p>OpenLDAP 默认以 <code>Berkeley DB</code> 作为后端数据库，BerkeleyDB 数据库主要以散列的数据类型进行数据存储，如以键值对的方式进行存储。</p><p><strong>BerkeleyDB 是一类特殊的面向查询进行优化、面向读取进行优化的数据库，主要用于搜索、浏览、更新查询操作，一般对于一次写入数据、多次查询和搜索有很好的效果</strong>。BerkeleyDB 不支持事务型数据库 (MySQL、MariDB、Oracle 等) 所支持的高并发的吞吐量以及复杂的事务操作。</p><h2 id="LDAP-简称目录"><a href="#LDAP-简称目录" class="headerlink" title="LDAP 简称目录"></a>LDAP 简称目录</h2><table><thead><tr><th>简称</th><th>全称（含义）</th></tr></thead><tbody><tr><td>c</td><td>countryName（国家）</td></tr><tr><td>dc</td><td>domainComponent（域名）</td></tr><tr><td>o</td><td>organization（组织 - 公司）</td></tr><tr><td>ou</td><td>organization unit（组织单元 - 部门）</td></tr><tr><td>sn</td><td>suer name（真实名称）</td></tr><tr><td>cn</td><td>common name（常用名称）</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;场景需求&quot;&gt;&lt;a href=&quot;#场景需求&quot; class=&quot;headerlink&quot; title=&quot;场景需求&quot;&gt;&lt;/a&gt;场景需求&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/2020/20200809201834.png&quot; alt=&quot;openldap-architecture&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;tag-plugin note&quot; color=&quot;orange&quot;&gt;&lt;div class=&quot;title&quot;&gt;&lt;strong&gt;需求&lt;/strong&gt;&lt;/div&gt;&lt;div class=&quot;body&quot;&gt;&lt;p&gt;当公司体量较大，内部有多个系统，如果每个平台都需要维护一个用户管理体系，那么如果一个员工拥有 N 个平台权限离职及常规权限变更，对于的管理无疑也是一个挑战，也无法做到精细化权限管理。比如每次新进或离职一位同事，我们这边 OPS 运维组的小伙伴们，都要在每个系统上去添加用户，搞得小伙伴们很不爽。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;简单说一下 OPENLDAP 对运维管理的价值，支撑企业技术发展比如 &lt;code&gt;GIT、 ZABBIX、 YAPI、 JUMPSERVER、 OA&lt;/code&gt; 等大大小小系统，乃至 Windows，Linux 系统的认证登录。&lt;/p&gt;</summary>
    
    
    
    <category term="折腾不止" scheme="https://liei.cc/blog/categories/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2/"/>
    
    
    <category term="OpenLDAP" scheme="https://liei.cc/blog/tags/openldap/"/>
    
  </entry>
  
  <entry>
    <title>模块设计文档编写规范</title>
    <link href="https://liei.cc/2019/module-design-doc.html"/>
    <id>https://liei.cc/2019/module-design-doc.html</id>
    <published>2019-11-25T07:15:15.000Z</published>
    <updated>2019-11-25T07:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块负责人"><a href="#模块负责人" class="headerlink" title="模块负责人"></a>模块负责人</h2><ul><li>  <strong>👩‍💻</strong> leeifme / XXXX项目</li><li>  <strong>🚀</strong> XXXX部门  /  XXXX事业部  </li><li>  <strong>📧</strong> Email <a href="mailto:&#105;&#x40;&#x6c;&#x65;&#101;&#x69;&#102;&#x2e;&#x6d;&#101;">&#105;&#x40;&#x6c;&#x65;&#101;&#x69;&#102;&#x2e;&#x6d;&#101;</a></li></ul><h2 id="版本历史记录-History-（可选）"><a href="#版本历史记录-History-（可选）" class="headerlink" title="版本历史记录(History) （可选）"></a>版本历史记录(History) （可选）</h2><blockquote><p>  设计稿版本每发生一次比较大的迭代更新，都要记录在版本历史记录里，相比一个个去翻以前的设计稿，版本历史记录可以清晰地展现设计稿的迭代历程，有哪些需求的变动，有哪些设计时没思考清楚需要修改的地方，Review 时大家给出了哪些意见和建议等。有时版本需要回滚，可以更方便地追溯，而项目结束后浏览这一部分，可以看到自己的设计在哪些方面一开始思考不足出现了各种问题，是如何被发现、改进和提升的，下一次设计的时候是否可以更早地思考到和回避掉</p></blockquote><h2 id="排期-Schedule-（可选）"><a href="#排期-Schedule-（可选）" class="headerlink" title="排期(Schedule) （可选）"></a>排期(Schedule) （可选）</h2><blockquote><p>  和需求方确认各阶段交付的时间节点，制定完成模块设计的具体计划，每个阶段大概做哪些工作，什么时候内部 Review，什么时候和项目组 Review 等。确保设计以一个合理的节奏展开，可以以较高的质量按时交付</p></blockquote><h2 id="模块概述-Background"><a href="#模块概述-Background" class="headerlink" title="模块概述(Background)"></a>模块概述(Background)</h2><blockquote><p>  这一部分的内容在开发者和 PM、业务方充分沟通需求之后完成 </p></blockquote><ul><li>  <strong>模块描述，要设计的产品是什么，解决什么业务需求</strong></li><li>  业务 / 产品现状，总结需求方现在面临的主要问题 </li><li>  <strong>功能设计，模块开发关键点以及业务逻辑描述</strong></li><li>  需要设计什么新的功能，需要优化哪些已有的设计 </li><li>  提高模块哪些使用环节的体验，引导用户做出什么操作</li></ul><h2 id="模块详细设计"><a href="#模块详细设计" class="headerlink" title="模块详细设计"></a>模块详细设计</h2><blockquote><p>  详细描述模块实现的架构分析，采用的框架、技术栈选型，以及实现算法等</p></blockquote><ul><li>  <strong>使用第三方服务</strong>：采用的框架、什么存储服务、数据库、队列等等的一些服务，以及可能需要用到的算法</li><li>  <strong>程序逻辑描述</strong>：有什么样的交互逻辑，处理流程是什么样的，是不是有异步处理任务又是怎样做的</li><li>  <strong>数据结构定义</strong>：程序内部主要用到的数据结构、数据库表设计、索引设计</li><li><strong>结构 / 架构图</strong>：根据使用了什么服务、有什么样的调用流程、或者是程序里面有什么样的结构和流程需要画的图<ul><li><a href="http://naotu.baidu.com/">百度脑图</a></li><li><a href="https://www.processon.com/">Process On</a></li></ul></li></ul><p><code>这些框架、设计都需经过可行性分析，必须是可行的</code></p><h2 id="接口设计文档-Interface"><a href="#接口设计文档-Interface" class="headerlink" title="接口设计文档(Interface)"></a>接口设计文档(Interface)</h2><blockquote><p>  主要参考 <code>Swagger</code>文档（如果有），这里只做一些补充说明，用来说明调用此接口需要注意的事项(没有可不写)</p></blockquote><h2 id="原型设计（可选）"><a href="#原型设计（可选）" class="headerlink" title="原型设计（可选）"></a>原型设计（可选）</h2><blockquote><p>原型设计之于应用开发，是为第一要素。它所起到的不仅是沟通的作用，更有体现之效。通过内容和结构展示，以及粗略布局，能够说明用户将如何与产品进行交互 。也能更直观的体现出所设计模块的基本功能和交互方式，体现开发者及UI设计师的idea，体现用户所期望看到的内容，体现内容相对优先级等 </p></blockquote><ul><li>  <a href="https://modao.cc/">墨刀</a></li><li>  <a href="https://www.mockplus.cn/">摹客</a></li><li>  <a href="https://www.axure.com.cn/">Axure RP</a></li></ul><h2 id="测试要点（可选）"><a href="#测试要点（可选）" class="headerlink" title="测试要点（可选）"></a>测试要点（可选）</h2><blockquote><p>  给出测试模块的主要测试要求，和逻辑操作</p></blockquote><p><code>注明：</code> 以上设计规范只是通用设计要求，具体视模块功能要求做具体改动</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模块负责人&quot;&gt;&lt;a href=&quot;#模块负责人&quot; class=&quot;headerlink&quot; title=&quot;模块负责人&quot;&gt;&lt;/a&gt;模块负责人&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;  &lt;strong&gt;👩‍💻&lt;/strong&gt; leeifme / XXXX项目&lt;/li&gt;
&lt;li&gt; </summary>
      
    
    
    
    <category term="设计开发" scheme="https://liei.cc/blog/categories/%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="规范建议" scheme="https://liei.cc/blog/tags/%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>搭建 Airflow 任务调度环境</title>
    <link href="https://liei.cc/2019/deploy-airflow.html"/>
    <id>https://liei.cc/2019/deploy-airflow.html</id>
    <published>2019-08-25T07:15:15.000Z</published>
    <updated>2019-08-25T07:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="关闭防火墙和-selinux"><a href="#关闭防火墙和-selinux" class="headerlink" title="关闭防火墙和 selinux"></a>关闭防火墙和 selinux</h3><pre><code class="hljs sh">systemctl stop firewalldsystemctl <span class="hljs-built_in">disable</span> firewalldsetenforce 0 sed -i <span class="hljs-string">&#x27;s/^SELINUX=.*/SELINUX=disabled/g&#x27;</span> /etc/selinux/config</code></pre><h3 id="部署-Python-3-X"><a href="#部署-Python-3-X" class="headerlink" title="部署 Python 3.X"></a>部署 Python 3.X</h3><ul><li><p>依赖包安装</p><p>  Python 安装会依赖一些环境，为了避免在安装过程中因为缺少依赖而产生不必要的麻烦，需要先执行以下命令，确保安装好以下依赖包：</p>  <pre><code class="hljs bash">yum -y install zlib zlib-develyum -y install bzip2 bzip2-develyum -y install ncurses ncurses-develyum -y install readline readline-develyum -y install openssl openssl-develyum -y install openssl-staticyum -y install xz lzma xz-develyum -y install sqlite sqlite-develyum -y install gdbm gdbm-develyum -y install tk tk-develyum -y install libffi-devel <span class="hljs-comment"># 只有 3.7 才会用到这个包，如果不安装这个包的话，在 make 阶段会出现如下的报错：ModuleNotFoundError: No module named &#x27;_ctypes&#x27;</span>yum install gccyum install wget<span class="hljs-comment"># 安装 pip，因为 CentOs 是没有 pip 的</span><span class="hljs-comment">#运行这个命令添加epel扩展源 </span>yum -y install epel-release <span class="hljs-comment">#安装pip </span>yum install python-pip</code></pre></li><li><p>Python 源码下载</p><p>  可以前往 <a href="https://www.python.org/ftp/python/">https://www.python.org/ftp/python/</a> 查看 Python 各个版本</p>  <pre><code class="hljs sh">wget https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgz</code></pre></li></ul><p>知识点补充：如果不知道 <code>configure, make, make install</code> 三个命令作用，<a href="https://www.cnblogs.com/tinywan/p/7230039.html">点这里查看</a></p><p><strong>安装 Python</strong></p><ul><li><p>解压缩</p>  <pre><code class="hljs sh">tar -zxvf Python-3.7.0.tgz</code></pre></li><li><p>进入解压后的目录，依次执行下面命令进行手动编译</p>  <pre><code class="hljs sh">./configure prefix=/usr/<span class="hljs-built_in">local</span>/python3 <span class="hljs-comment"># 指定目录</span>make &amp;&amp; make install</code></pre><p>  如果最后没提示出错，就代表正确安装了</p></li><li><p>添加软链接</p>  <pre><code class="hljs sh"><span class="hljs-comment"># 做好原始数据的备份</span>mv /usr/bin/python /usr/bin/python2.backup mv /usr/bin/pip /usr/bin/pip2.backup<span class="hljs-comment"># 设置软连接</span>ln -s /usr/<span class="hljs-built_in">local</span>/python3/bin/python3.7 /usr/bin/pythonln -s /usr/<span class="hljs-built_in">local</span>/python3/bin/pip3.7 /usr/bin/pip<span class="hljs-comment"># 检测</span>python -Vpip -V</code></pre></li><li><p>保证系统可用</p><p>  更改 yum 配置，因为其要用到 python2 才能执行，否则会导致 yum 不能正常使用（不管安装 python3 的那个版本，都必须要做的）</p>  <pre><code class="hljs yaml"><span class="hljs-comment"># 把 #! /usr/bin/python 修改为 #! /usr/bin/python2 </span><span class="hljs-string">vi</span> <span class="hljs-string">/usr/bin/yum</span> <span class="hljs-string">vi</span> <span class="hljs-string">/usr/libexec/urlgrabber-ext-down</span></code></pre></li></ul><h3 id="部署-PostgreSQL"><a href="#部署-PostgreSQL" class="headerlink" title="部署 PostgreSQL"></a>部署 PostgreSQL</h3><ul><li><p>安装 PostgreSQL 仓库</p>  <pre><code class="hljs sh">$ yum install https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm</code></pre></li><li><p>安装客户端</p>  <pre><code class="hljs sh">$ yum install postgresql10</code></pre></li><li><p>安装服务端</p>  <pre><code class="hljs sh">$ yum install postgresql10-server</code></pre></li><li><p>加入开机启动项</p>  <pre><code class="hljs sh">$ systemctl <span class="hljs-built_in">enable</span> postgresql-10.service</code></pre></li><li><p>初始化数据库</p>  <pre><code class="hljs sh">$ /usr/pgsql-10/bin/postgresql-10-setup initdb</code></pre></li><li><p>启动数据库服务</p>  <pre><code class="hljs sh">$ systemctl start postgresql-10</code></pre></li><li><p>检查运行状态</p>  <pre><code class="hljs sh">$ systemctl status postgresql-10</code></pre></li><li><p>设置用户密码</p>  <pre><code class="hljs sh">$ su - postgresLast login: Mon Aug  5 11:09:14 CST 2019 on pts/0<span class="hljs-comment"># 默认用户postgres</span>-bash-4.2$ psqlpsql (10.9)Type <span class="hljs-string">&quot;help&quot;</span> <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>.postgres=<span class="hljs-comment"># \password</span><span class="hljs-comment"># 设置密码为 &#x27;******&#x27;</span>Enter new password:Enter it again:<span class="hljs-comment"># 保存退出</span>postgres=<span class="hljs-comment"># \q</span></code></pre></li><li><p>修改监听地址</p><p>  <code>vi /var/lib/pgsql/10/data/postgresql.conf </code></p>  <pre><code class="hljs sh">listen_addresses = <span class="hljs-string">&#x27;*&#x27;</span><span class="hljs-comment">#listen_addresses = &#x27;localhost&#x27;</span></code></pre></li><li><p>修改客户端认证方式</p><p>  <code>vi /var/lib/pgsql/10/data/pg_hba.conf</code></p>  <pre><code class="hljs sh"><span class="hljs-comment"># replication privilege.</span><span class="hljs-comment">#local   replication     all                                     peer</span><span class="hljs-comment">#host    replication     all             127.0.0.1/32            ident</span><span class="hljs-comment">#host    replication     all             ::1/128                 ident</span>host    all     all             0.0.0.0/0                 md5</code></pre></li><li><p>重启服务</p>  <pre><code class="hljs sh">$ systemctl restart postgresql-10</code></pre></li><li><p>连接测试</p>  <pre><code class="hljs sh">$ psql -h 192.168.1.2 -U postgres</code></pre></li></ul><h3 id="部署-RabbitMQ"><a href="#部署-RabbitMQ" class="headerlink" title="部署 RabbitMQ"></a>部署 RabbitMQ</h3><p><strong>安装 Erlang</strong></p><p>RabbitMQ 是使用 Erlang 开发的，所以需要首先安装 Erlang，本文安装其最新版本</p><ul><li><p>添加 repo 文件：</p>  <pre><code class="hljs sh">$ vi /etc/yum.repos.d/rabbitmq_erlang.repo</code></pre><p>  文件内容：</p>  <pre><code class="hljs sh">[rabbitmq_erlang]name=rabbitmq_erlangbaseurl=https://packagecloud.io/rabbitmq/erlang/el/7/<span class="hljs-variable">$basearch</span>repo_gpgcheck=1gpgcheck=0enabled=1gpgkey=https://packagecloud.io/rabbitmq/erlang/gpgkeysslverify=1sslcacert=/etc/pki/tls/certs/ca-bundle.crtmetadata_expire=300[rabbitmq_erlang-source]name=rabbitmq_erlang-sourcebaseurl=https://packagecloud.io/rabbitmq/erlang/el/7/SRPMSrepo_gpgcheck=1gpgcheck=0enabled=1gpgkey=https://packagecloud.io/rabbitmq/erlang/gpgkeysslverify=1sslcacert=/etc/pki/tls/certs/ca-bundle.crtmetadata_expire=300</code></pre></li><li><p>安装：</p>  <pre><code class="hljs sh">$ yum -y install erlang socat</code></pre></li></ul><p><strong>安装 RabbitMQ</strong></p><ul><li><p>下载 RPM 包：</p>  <pre><code class="hljs sh">$ wget https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.17/rabbitmq-server-3.7.17-1.el7.noarch.rpm</code></pre></li><li><p>导入 GPG key：</p>  <pre><code class="hljs sh">$ rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc</code></pre></li><li><p>安装 RabbitMQ：</p>  <pre><code class="hljs sh">$ rpm -Uvh rabbitmq-server-3.7.17-1.el7.noarch.rpm</code></pre></li><li><p>启动 RabbitMQ：</p>  <pre><code class="hljs sh">$ systemctl start rabbitmq-server</code></pre></li><li><p>查看 RabbitMQ 运行状态</p>  <pre><code class="hljs sh">$ systemctl status rabbitmq-server</code></pre></li><li><p>将 RabbitMQ 加入开机自启动：</p>  <pre><code class="hljs sh">$ systemctl <span class="hljs-built_in">enable</span> rabbitmq-server</code></pre></li></ul><p><strong>RabbitMQ 配置</strong></p><ul><li><p>启用 RabbitMQ 网页管理插件</p>  <pre><code class="hljs sh">$ rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_management</code></pre></li><li><p>创建管理员用户并授权：</p>  <pre><code class="hljs sh">$ rabbitmqctl add_user admin 你的密码$ rabbitmqctl set_user_tags admin administrator$ rabbitmqctl set_permissions -p / admin <span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-string">&quot;.*&quot;</span></code></pre></li></ul><p>在浏览器访问 <a href="http://ip:15672/">http://IP:15672</a> 即可进入到 RabbitMQ 网页管理页面</p><h2 id="部署-Airflow"><a href="#部署-Airflow" class="headerlink" title="部署 Airflow"></a>部署 Airflow</h2><h3 id="通过-pip-安装-airflow-脚手架"><a href="#通过-pip-安装-airflow-脚手架" class="headerlink" title="通过 pip 安装 airflow 脚手架"></a>通过 pip 安装 airflow 脚手架</h3><p>安装之前需要设置一下临时环境变量 <code>SLUGIFY_USES_TEXT_UNIDECODE</code> ，不然，会导致安装失败，命令如下：</p><pre><code class="hljs sh"><span class="hljs-built_in">export</span> SLUGIFY_USES_TEXT_UNIDECODE=yes</code></pre><ul><li><p>安装 airflow 脚手架:</p>  <pre><code class="hljs sh">sudo pip install apache-airflow===1.10.4</code></pre><p>  airflow 会被安装到 python3 下的 site-packages 目录下，完整目录为:<code>$&#123;PYTHON_HOME&#125;/lib/python3.6/site-packages/airflow</code>，我的 airflow 目录如下所示：</p>  <pre><code class="hljs sh">[root@n71 airflow]<span class="hljs-comment"># pwd</span>/usr/<span class="hljs-built_in">local</span>/python3/lib/python3.7/site-packages/airflow</code></pre></li><li><p>添加环境变量</p><p>  <code>vi ~/.bash_profile</code></p>  <pre><code class="hljs sh"><span class="hljs-comment"># User specific environment and startup programs</span>AIRFLOW_HOME=/home/airflowSITE_AIRFLOW_HOME=/usr/<span class="hljs-built_in">local</span>/python3/lib/python3.7/site-packages/airflowPYTHON3=/usr/<span class="hljs-built_in">local</span>/python3PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/bin:<span class="hljs-variable">$SITE_AIRFLOW_HOME</span>/bin:<span class="hljs-variable">$PYTHON3</span>/bin<span class="hljs-built_in">export</span> AIRFLOW_HOME<span class="hljs-built_in">export</span> SITE_AIRFLOW_HOME<span class="hljs-built_in">export</span> PATH<span class="hljs-built_in">export</span> C_FORCE_ROOT=<span class="hljs-literal">true</span></code></pre><p>  使修改后的使环境变量生效：<code>sudo source /etc/profile</code></p></li></ul><h3 id="Airflow-相关操作"><a href="#Airflow-相关操作" class="headerlink" title="Airflow 相关操作"></a>Airflow 相关操作</h3><ul><li><p>执行 <code>airflow</code> 命令做初始化操作</p>  <pre><code class="hljs sh">airflow</code></pre><p>  airflow 会在刚刚的 <code>AIRFLOW_HOME</code> 目录下生成一些文件。当然，执行该命令时可能会报一些错误，可以不用理会！生成的文件列表如下所示：</p>  <pre><code class="hljs sh">[root@n71 airflow]<span class="hljs-comment"># ls</span>airflow.cfg  logs  unittests.cfg</code></pre></li><li><p>为 <code>airflow</code> 安装依赖模块</p>  <pre><code class="hljs sh">pip install <span class="hljs-string">&#x27;apache-airflow[postgres,celery,hive,rabbitmq]&#x27;</span></code></pre><p>  airflow 的包依赖安装均可采用该方式进行安装，具体可参考 <a href="https://link.juejin.im/?target=https://airflow.apache.org/installation.html">airflow 官方文档</a></p></li></ul><h3 id="遇到的坑以及解决方案"><a href="#遇到的坑以及解决方案" class="headerlink" title="遇到的坑以及解决方案"></a><strong>遇到的坑以及解决方案</strong></h3><ul><li><p><strong>为 <code>airflow</code> 安装 [rabbitmq] 依赖模块报错</strong></p><p>  具体可以参看这个 <code>repositories</code> <a href="https://github.com/celery/librabbitmq">https://github.com/celery/librabbitmq</a></p><p>  <strong>解决方案：</strong></p>  <pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/celery/librabbitmq.git<span class="hljs-built_in">cd</span> librabbitmqcheckout 1.6yum install install autoconf automake libtoolmake install<span class="hljs-comment"># 在安装依赖模块</span>pip install <span class="hljs-string">&#x27;apache-airflow[rabbitmq]&#x27;</span></code></pre></li><li><p><strong>启动 webserver 组件时报错</strong></p><p>  错位如下：</p>  <pre><code class="hljs sh">Error: <span class="hljs-string">&#x27;python:airflow.www.gunicorn_config&#x27;</span> doesn‘t exist</code></pre><p>  或者是：</p>  <pre><code class="hljs sh">FileNotFoundError: [Errno 2] No such file or directory: <span class="hljs-string">&#x27;gunicorn&#x27;</span>: <span class="hljs-string">&#x27;gunicorn&#x27;</span></code></pre><p>  <strong>解决方案：</strong></p>  <pre><code class="hljs sh"><span class="hljs-comment"># 1 :  添加软连接</span>ln -s /usr/<span class="hljs-built_in">local</span>/python3/bin/gunicorn /usr/bin/gunicorn<span class="hljs-comment"># 2  :  添加 python 环境变量</span>PYTHON3=/usr/<span class="hljs-built_in">local</span>/python3PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/bin:<span class="hljs-variable">$SITE_AIRFLOW_HOME</span>/bin:<span class="hljs-variable">$PYTHON3</span>/bin</code></pre></li><li><p><strong><code>airflow worker</code> 角色不能使用 root 启动</strong></p><p>  ==原因：不能用根用户启动的根本原因，在于 airflow 的 worker 直接用的 celery，而 celery 源码中有参数默认不能使用 ROOT 启动，否则将报错：==</p>  <pre><code class="hljs sh">C_FORCE_ROOT = os.environ.get(<span class="hljs-string">&#x27;C_FORCE_ROOT&#x27;</span>, False)    ROOT_DISALLOWED = <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;\</span><span class="hljs-string">Running a worker with superuser privileges when the</span><span class="hljs-string">worker accepts messages serialized with pickle is a very bad idea!</span><span class="hljs-string">    </span><span class="hljs-string">If you really want to continue then you have to set the C_FORCE_ROOT</span><span class="hljs-string">environment variable (but please think about this before you do).</span><span class="hljs-string">    </span><span class="hljs-string">User information: uid=&#123;uid&#125; euid=&#123;euid&#125; gid=&#123;gid&#125; egid=&#123;egid&#125;</span><span class="hljs-string">&quot;</span><span class="hljs-string">&quot;&quot;</span>    ROOT_DISCOURAGED = <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;\</span><span class="hljs-string">You&#x27;re running the worker with superuser privileges: this is</span><span class="hljs-string">absolutely not recommended!</span><span class="hljs-string">    </span><span class="hljs-string">Please specify a different user using the --uid option.</span><span class="hljs-string">    </span><span class="hljs-string">User information: uid=&#123;uid&#125; euid=&#123;euid&#125; gid=&#123;gid&#125; egid=&#123;egid&#125;</span><span class="hljs-string">&quot;</span><span class="hljs-string">&quot;&quot;</span></code></pre><p>  <strong>解决方案：</strong></p>  <pre><code class="hljs sh"><span class="hljs-comment"># 设置环境变量,  强制celery worker运行采用root模式</span> <span class="hljs-built_in">export</span> C_FORCE_ROOT=True</code></pre></li><li><p><strong><code>airflow remote worker log hostname</code> 问题</strong></p><p>  当 worker 节点不是跟 webserver 部署在同一台机器的时候，有时从 webserver 查看该 worker 节点日志，出现如下错误：</p>  <pre><code class="hljs go">*** Log file isn<span class="hljs-string">&#x27;t local.</span><span class="hljs-string">*** Fetching here: http://n73:8793/log/.../1.log</span><span class="hljs-string">*** Failed to fetch log file from worker. HTTPConnectionPool(host=&#x27;</span>kaimanas.serveriai.lt<span class="hljs-string">&#x27;, port=8793): Max retries exceeded with url: /log/.../1.log (Caused by NewConnectionError(&#x27;</span>&lt;urllib3.connection.HTTPConnection object at <span class="hljs-number">0x7f64da2fab38</span>&gt;: Failed to establish a <span class="hljs-built_in">new</span> connection: [Errno <span class="hljs-number">111</span>] Connection refused<span class="hljs-string">&#x27;,))</span></code></pre><p>  n73 (或是其他) 不是 webserver 节点所在的 hostname</p><p>  <strong>解决方案：</strong></p><p>  配置 worker 节点的 <code>/etc/hosts</code> 的 hostname 映射，把 worker 节点的 ip 映射为本机的 hostname，如下：</p>  <pre><code class="hljs sh">192.168.50.71 n71192.168.50.72 n72192.168.50.73 n73</code></pre></li></ul><h2 id="配置-airflow-cfg"><a href="#配置-airflow-cfg" class="headerlink" title="配置 airflow.cfg"></a>配置 airflow.cfg</h2><ul><li><p>修改 Executor 为 CeleryExecutor</p>  <pre><code class="hljs plain">executor &#x3D; CeleryExecutor</code></pre></li><li><p>指定元数据库（metestore)</p>  <pre><code class="hljs go">sql_alchemy_conn = postgresql+psycopg2:<span class="hljs-comment">//postgres:postgres@192.168.50.73:5432/airflow</span></code></pre></li><li><p>设置中间人（broker)</p>  <pre><code class="hljs go">broker_url = amqp:<span class="hljs-comment">//admin:datatom.com@192.168.50.73:5672/</span></code></pre></li><li><p>设定结果存储后端 backend</p>  <pre><code class="hljs go">celery_result_backend = db+postgres:<span class="hljs-comment">//postgres:postgres@192.168.50.73:5432/airflow</span>result_backend = db+postgres:<span class="hljs-comment">//stork:stork@192.168.50.73:14103/airflow</span></code></pre></li><li><p>置 dags 初始化后为暂停状态(启动状态)</p>  <pre><code class="hljs go">dags_are_paused_at_creation = True(False)</code></pre></li><li><p>不引用实例脚本</p>  <pre><code class="hljs go">load_examples = False</code></pre></li><li><p>当定义的 dag 文件过多的时候，airflow 的 scheduler 节点运行效率缓慢</p>  <pre><code class="hljs go">[scheduler]# The scheduler can run multiple threads in parallel to schedule dags.# This defines how many threads will run.#默认是<span class="hljs-number">2</span>这里改为<span class="hljs-number">50</span>max_threads = <span class="hljs-number">30</span>worker_concurrency = <span class="hljs-number">5</span>worker_max_tasks_per_child = <span class="hljs-number">10</span></code></pre></li><li><p>修改检测新 DAG 间隔，如果 scheduler 检测 DAG 过于频繁，会导致 CPU 负载非常高。而默认 scheduler 检测时间为 0，也就是没有时间间隔</p>  <pre><code class="hljs go">min_file_process_interval = <span class="hljs-number">5</span></code></pre></li><li><p>定期刷新 DAG 定义目录中的文件列表，默认300s</p>  <pre><code class="hljs go">dag_dir_list_interval = <span class="hljs-number">10</span></code></pre></li><li><p>Airflow 的 DAG 并行度控制</p><p>  <code>dag_concurrency</code>：表示一个 DAG，在同一时间点最大可以运行多少个 Task<br>  <code>max_active_runs_per_dag</code>：表示一个 DAG，在同一时间点最多可以被运行几个</p>  <pre><code class="hljs go"># 默认值都为<span class="hljs-number">16</span>dag_concurrency = <span class="hljs-number">16</span>max_active_runs_per_dag = <span class="hljs-number">16</span></code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;&gt;&lt;/a&gt;前期准备&lt;/h2&gt;&lt;h3 id=&quot;关闭防火墙和-selinux&quot;&gt;&lt;a href=&quot;#关闭防火墙和-selinux&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="折腾不止" scheme="https://liei.cc/blog/categories/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2/"/>
    
    
    <category term="Python" scheme="https://liei.cc/blog/tags/python/"/>
    
    <category term="Airflow" scheme="https://liei.cc/blog/tags/airflow/"/>
    
  </entry>
  
  <entry>
    <title>GFS 一致性模型</title>
    <link href="https://liei.cc/2019/gfs-consistency.html"/>
    <id>https://liei.cc/2019/gfs-consistency.html</id>
    <published>2019-07-15T06:15:15.000Z</published>
    <updated>2019-07-15T06:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="tag-plugin note" ><div class="title"><strong>quote,</strong></div><div class="body"><p>最近，部门内部组织了学习活动，前两课就是研读著名的可扩展分布式文件系统 GFS 论文，并布置了学习作业，就是整理 GFS 中提出的一致性模型，如下文：</p></div></div><h2 id="一致性背景"><a href="#一致性背景" class="headerlink" title="一致性背景"></a>一致性背景</h2><p>分布式存储系统中，不管是文件系统还是数据库，只要数据存在多个副本，都涉及一致性问题。其中一致性包括内部一致性和副本一致性，内部一致性即单机版数据库中的数据满足一定的约束条件。副本一致性表示同一数据的多个副本的值相同。GFS 作为一种分布式文件系统，采用了多副本机制，自然也会有一致性问题</p><h2 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h2><p><img src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/2019/GFS%20%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B%402x.png" alt="GFS 一致性模型"></p><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p><strong>修改操作：</strong> 包括写操作和追加操作，写操作需要指定文件块 + offset。追加操作成功后系统会将追加成功的偏移量返回给客户端。</p><p><strong>并发写：</strong> 如果两个客户端同时写同一个文件块的同一偏移量，那么就有个先后顺序问题，如果接近同时，系统不保证这个顺序。那么客户端再去读，就不一定能读到自己刚写的数据。</p><p><strong>追加失败：</strong> 追加操作会保证至少成功一次。追加操作时，假设配置三副本，但是只有两个副本写成功，最后一个副本超时了（可能对应块服务器宕机，当然重启后 GFS 会用 chunk version 来标记其过期 stale 了，从而跳过该 offset。），那么追加操作会重试，并且失败数据不会删除，但是 GFS 有对齐操作，即重试成功后，三个副本中该追加数据的起始偏移量是定义的（也就是一致的），那么其中那个上次失败的副本就会有个空洞，系统会用特殊字符填充。</p><div class="tag-plugin note" ><div class="title"><strong>info,</strong></div><div class="body"><p>结论： 定义未定义针对的是多客户端并发写同一个偏移量的覆盖顺序问题；一致不一致针对的是多个副本相同偏移量的内容是否相同</p></div></div><h2 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h2><p><strong>已定义（defined）</strong>：客户端写某个偏移量后，再读，读到的一定是自己的。</p><p><strong>未定义的但是一致的（undefined but consistent）</strong>：多个客户端并发写同一个偏移量，不确定谁会覆盖谁（这个顺序由 Primary Replica 所在 Chunkserver 来安排，后面将会讲），即写完后再读，不确定是自己写的还是其他人写的。但是保证最终一致性，即并发写完成后，最后几个副本是一致的。</p><p><strong>不一致的（inconsistent）</strong>：即修改操作后，所有副本同一偏移量的数据并不完全相同。</p>]]></content>
    
    
    <summary type="html">分布式存储系统中，不管是文件系统还是数据库，只要数据存在多个副本，都涉及一致性问题。其中一致性包括内部一致性和副本一致性，内部一致性即单机版数据库中的数据满足一定的约束条件。副本一致性表示同一数据的多个副本的值相同。GFS 作为一种分布式文件系统，采用了多副本机制，自然也会有一致性问题</summary>
    
    
    
    <category term="解决方案" scheme="https://liei.cc/blog/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="分布式" scheme="https://liei.cc/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>go pprof 性能分析</title>
    <link href="https://liei.cc/2019/go-pprof-analysis.html"/>
    <id>https://liei.cc/2019/go-pprof-analysis.html</id>
    <published>2019-05-20T06:15:15.000Z</published>
    <updated>2019-05-20T06:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><div class="tag-plugin note" ><div class="title"><strong>warning,</strong></div><div class="body"><p>线上运行的基础平台文件管理服务进程出现内存泄露的现象，下图是 <code>grafana</code> 针对该服务的监控指标情况，可以发现服务刚起时，内存使用量为 <strong>20M</strong> 左右，经过操作后，内存会稳定在 <strong>300M</strong> 左右，不会持续上升，也不会下降，一开始找不到原因，所以尝试使用一下 golang pprof 性能分析工具分析一下程序到底哪出问题了</p></div></div><p><img src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/2019/005TUXkXly1g3jdrwfy0zj31hc0r3tcp.jpg"></p><p><img src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/2019/005TUXkXly1g3jdrwawt6j31hc0r3dhp.jpg"></p><h2 id="添加-pprof-模块"><a href="#添加-pprof-模块" class="headerlink" title="添加 pprof 模块"></a>添加 pprof 模块</h2><p>现在最新版本的 go tool 分析工具已经很人性化了，pprof 采样数据主要有三种获取方式:</p><ul><li>  <strong>runtime/pprof</strong>: 手动调用<code>runtime.StartCPUProfile</code>或者<code>runtime.StopCPUProfile</code>等 API 来生成和写入采样文件，灵活性高，适用于<code>应用程序</code></li><li>  <strong>net/http/pprof</strong>: 通过 http 服务获取 Profile 采样文件，简单易用，适用于对应用程序的整体监控，通过 runtime/pprof 实现，适用于<code>web服务程序、服务进程</code></li><li>  <strong>go test</strong>: 通过 <code>go test -bench . -cpuprofile prof.cpu</code>生成采样文件 适用对函数进行针对性测试</li></ul><blockquote class="pullquote right @leeifme , 睡沙发的沙皮狗"><p>其实 net/http/pprof 中只是使用 runtime/pprof 包来进行封装了一下，并在 http 端口上暴露出来，让我们可以在浏览器查看程序的性能分析。可以自行查看 net/http/pprof 中代码，只有一个文件 pprof.go。</p></blockquote><p>以上获取方式就不详细演示了，毕竟着重于解决当下问题，由于所要分析的服务程序依赖于 <code>gin web 框架</code> ，因此要在 <code>gin</code> 中集成 pprof；</p><p><strong>Example：</strong></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;github.com/gin-contrib/pprof&quot;</span>  <span class="hljs-comment">// step 1</span>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  router := gin.Default()  pprof.Register(router)   <span class="hljs-comment">// step 2</span>  router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)&#125;</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>启动程序，通过服务端口即可访问 pprof 的数据</p><p>查看当前总览：访问 <code>http://$HOSTIP:$PORT/debug/pprof</code></p><p><img src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/2019/005TUXkXly1g3ic456o71j313m0f70tl.jpg"></p><pre><code class="hljs plain">cpu（CPU Profiling）: $HOST&#x2F;debug&#x2F;pprof&#x2F;profile，默认进行 30s 的 CPU Profiling，得到一个分析用的 profile 文件block（Block Profiling）：$HOST&#x2F;debug&#x2F;pprof&#x2F;block，查看导致阻塞同步的堆栈跟踪goroutine：$HOST&#x2F;debug&#x2F;pprof&#x2F;goroutine，查看当前所有运行的 goroutines 堆栈跟踪heap（Memory Profiling）: $HOST&#x2F;debug&#x2F;pprof&#x2F;heap，查看活动对象的内存分配情况mutex（Mutex Profiling）：$HOST&#x2F;debug&#x2F;pprof&#x2F;mutex，查看导致互斥锁的竞争持有者的堆栈跟踪threadcreate：$HOST&#x2F;debug&#x2F;pprof&#x2F;threadcreate，查看创建新 OS 线程的堆栈跟踪</code></pre><p>这里，我更多的是做程序的内存分析，并通过交互式终端使用；</p><p>在 terminal 中使用 <code>go tool pprof http://$HOSTIP:$PORT/debug/pprof/heap</code> 可以进入 pprof 分析工具，比如输入 <code>top</code> 可以显示靠前的几项，go tool pprof 可以带上参数 <code>-inuse_space</code> (分析应用程序的常驻内存占用情况) 或者 <code>-alloc_space</code> (分析应用程序的内存临时分配情况)</p><p>现在 go tool 可以直接可视化结果，只需要带上 <code>-http=:8081</code> 参数即可，如：</p><pre><code class="hljs sh">$ go tool pprof -http=:8081 http://<span class="hljs-variable">$HOSTIP</span>:<span class="hljs-variable">$PORT</span>/debug/pprof/heap</code></pre><p>之后就会在浏览器弹出 <code>http://$HOSTIP:8081/ui</code>，里面包含程序内存分析的 dot 格式的图、火焰图、top 列表、source 列表等，如下：</p><p><img src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/2019/005TUXkXly1g3je0lzugdj31hc0r3q3u.jpg"></p><p><img src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/2019/005TUXkXly1g3je0m0bjuj31hc0r3aby.jpg"></p><p><img src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/2019/005TUXkXly1g3je0m0mu5j31hc0r341g.jpg"></p><p><img src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/2019/005TUXkXly1g3je0m09v2j31hc0r30uc.jpg"></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>内存消耗停滞在一个值时，比如上述问题描述，其实不用称之为内存泄漏，而是不主动 GC，需要主动释放内存；</p><p>导致这个问题的原因是由于上传文件时，采用 <code>multipart/form-data</code> 传输数据，<code>r.FormFile(&quot;file&quot;)</code> 将导致调用Request.ParseMultipartForm()，并将32 MB用作maxMemory参数的值，创建 32M 的缓冲区；由于<code>bytes.Buffer</code> 用于读取内容，因此读取过程将从一个小的或空的缓冲区开始，并在需要更大的时候重新分配；</p><p>有关详细信息，请参阅 <a href="https://golang.org/pkg/mime/multipart/#Reader.ReadForm"><strong>multipart.Reader.ReadFrom()</strong></a> 的实现。</p><pre><code class="hljs go">r.ParseMultipartForm(<span class="hljs-number">32</span> &lt;&lt; <span class="hljs-number">20</span>) <span class="hljs-comment">// 32 MB</span>file, _, err := r.FormFile(<span class="hljs-string">&quot;file&quot;</span>)<span class="hljs-comment">// ... rest of your handler</span></code></pre><blockquote class="pullquote @leeifme , 睡沙发的沙皮狗"><p>详细描述可以参考 <strong>stackoverflow</strong> 上的回答，<a href="https://stackoverflow.com/questions/30657454/multipart-form-uploads-memory-leaks-in-golang">Multipart form uploads + memory leaks in golang?</a></p></blockquote><p>这里优化的方案是在 <code>request</code>请求的 <code>body</code> 中只放文件数据，其余信息放到 <code>header</code> 中，这样就不需要使用 MultipartForm 去解析数据；</p><pre><code class="hljs go">file = r.Body<span class="hljs-comment">// ... rest of your handler</span></code></pre><p>可以看到传输完成后，内存占用恢复到了服务初始的状态值</p><p><img src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/2019/20190627151301.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/EDDYCJY/blog/blob/master/golang/2018-09-15-Golang%20%E5%A4%A7%E6%9D%80%E5%99%A8%E4%B9%8B%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90%20PProf.md">Golang 大杀器之性能剖析 PProf</a></p><p><a href="https://stackoverflow.com/questions/30657454/multipart-form-uploads-memory-leaks-in-golang">Multipart form uploads + memory leaks in golang?</a></p>]]></content>
    
    
    <summary type="html">线上运行的基础平台文件管理服务进程出现内存泄露的现象，下图是 `grafana` 针对该服务的监控指标情况，可以发现服务刚起时，内存使用量为 **20M** 左右，经过操作后，内存会稳定在 **300M** 左右，不会持续上升，也不会下降，一开始找不到原因，所以尝试使用一下 golang pprof 性能分析工具分析一下程序到底哪出问题了</summary>
    
    
    
    <category term="设计开发" scheme="https://liei.cc/blog/categories/%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go" scheme="https://liei.cc/blog/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Opeartor-SDK 简单上手</title>
    <link href="https://liei.cc/2019/operator-sdk-use.html"/>
    <id>https://liei.cc/2019/operator-sdk-use.html</id>
    <published>2019-02-28T06:15:15.000Z</published>
    <updated>2019-02-28T06:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>  本篇介绍了CoreOS（已被红帽收购）的开源项目 <a href="https://github.com/operator-framework/operator-sdk">Operator-SDK</a> 的基本使用。该项目是 <code>Operator Framework</code> 的一个组件，它是一个开源工具包，以有效，自动化和可扩展的方式管理称为 <code>Operators</code> 的Kubernetes原生应用程序</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><a href="https://coreos.com/operators/">Operators</a> 可以在Kubernetes之上轻松地管理复杂有状态的应用程序。然而，由于诸如使用低级API，编写样板以及缺乏模块导致重复性工作等挑战，导致目前编写Operator可能很困难</p><p>Operator SDK是一个框架，旨在简化Operator的编写，它提供如下功能：</p><ul><li>  高级API和抽象，更直观地编写操作逻辑</li><li>  用于脚手架和代码生成的工具，可以快速引导新项目</li><li>  扩展以涵盖常见的操作员用例</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>SDK提供以下工作流程来开发新的Operator：</p><ol><li> 使用SDK命令行界面（CLI）创建新的Operator项目</li><li> 通过添加自定义资源定义（CRD）定义新资源API</li><li> 使用SDK API监控指定的资源</li><li> 在指定的处理程序中定义Operator协调逻辑(对比期望状态与实际状态)，并使用SDK API与资源进行交互</li><li> 使用SDK CLI构建并生成Operator部署manifests</li></ol><p>Operator使用SDK在用户自定义的处理程序中以高级API处理监视资源的事件，并采取措施来reconcile（对比期望状态与实际状态）应用程序的状态</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="安装-Operator-SDK-CLI"><a href="#安装-Operator-SDK-CLI" class="headerlink" title="安装 Operator-SDK CLI"></a>安装 Operator-SDK CLI</h3><pre><code class="hljs bash">$ mkdir -p <span class="hljs-variable">$GOPATH</span>/src/github.com/operator-framework$ <span class="hljs-built_in">cd</span> <span class="hljs-variable">$GOPATH</span>/src/github.com/operator-framework$ git <span class="hljs-built_in">clone</span> https://github.com/operator-framework/operator-sdk$ <span class="hljs-built_in">cd</span> operator-sdk$ git checkout master$ make dep$ make install</code></pre><p><strong>注：</strong>这里可知，<code>Operator-SDK</code> 默认采用 <code>dep</code> 作为包管理方式，但 <code>dep</code> 当前的执行效率的确不高，如果你的 project 依赖的外部包很多，那么等待的时间可能会很长。并且由于 dep 会下载依赖包，一旦下载 qiang 外的包，那么 dep 可能会 “阻塞” 在那里！因此这里可以选择自己拉包后 <code>go install</code></p><h3 id="创建-app-operator"><a href="#创建-app-operator" class="headerlink" title="创建 app-operator"></a>创建 app-operator</h3><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个定义 App 用户资源的 app-operator 项目</span>$ mkdir -p <span class="hljs-variable">$GOPATH</span>/src/github.com/&lt;GitHub_ID&gt;<span class="hljs-comment"># 创建 app-operator 项目</span>$ <span class="hljs-built_in">cd</span> <span class="hljs-variable">$GOPATH</span>/src/github.com/&lt;GitHub_ID&gt;$ operator-sdk new app-operator  $ <span class="hljs-built_in">cd</span> app-operator<span class="hljs-comment"># 为AppService用户资源添加一个新的 API</span>$ operator-sdk add api --api-version=app.example.com/v1alpha1 --kind=AppService<span class="hljs-comment"># Required: --kind - 是 CRD 要定義的 kind</span><span class="hljs-comment"># Required: --api-version - 是CRD 想定义的 group/version。</span><span class="hljs-comment"># 添加一个新的控制器来监控 AppService</span>$ operator-sdk add controller --api-version=app.example.com/v1alpha1 --kind=AppService<span class="hljs-comment"># 构建并推送 app-operator 镜像到一个公开的 registry</span><span class="hljs-comment"># 这里 build 镜像，使用的基础镜像，由于不可描述的原因，非常耗时</span><span class="hljs-comment"># 可替换为 ： FROM docker.io/ericnie2017/helm-operator:latest</span>$ operator-sdk build app-operator:v0.1.0$ docker push <span class="hljs-comment"># 更新 operator manifest 来使用新构建的镜像</span>$ sed -i <span class="hljs-string">&#x27;s|REPLACE_IMAGE|app-operator:v0.1.0|g&#x27;</span> deploy/operator.yaml</code></pre><p><strong>注：</strong>这里采用 <code>operator-sdk new </code> 创建 app-operator 时，会自动生成 <code>Gopkg.toml</code> 并使用 <code>dep</code> 下载依赖包，最好挂代理，不然非常耗时，也可以直接跳过，自己拉包编译</p><h3 id="创建-app-operator-for-Helm"><a href="#创建-app-operator-for-Helm" class="headerlink" title="创建 app-operator for Helm"></a>创建 app-operator for Helm</h3><pre><code class="hljs bash"><span class="hljs-comment"># 其他步骤都一样</span><span class="hljs-comment"># 只是再创建 app-operator 时，增加 --type=helm，并且再创建 helm 类型的 operator 时，可以直接 add api 和 kind</span>$ operator-sdk new &lt;project-name&gt; --<span class="hljs-built_in">type</span>=helm --kind=&lt;kind&gt; --api-version=&lt;group/version&gt; <span class="hljs-comment"># 例如</span>$ operator-sdk new app-operator api --api-version=app.example.com/v1alpha1 --kind=AppService --<span class="hljs-built_in">type</span>=helm</code></pre><h3 id="部署-app-operator"><a href="#部署-app-operator" class="headerlink" title="部署 app-operator"></a>部署 app-operator</h3><p>上述两种创建方式，都会自动生成 <code>/deploy</code> 文件夹，其中包含一组可以 deploy 到 K8s cluser 上的 resource files；</p><ul><li>  <strong>deploy/service_account.yaml</strong>: 建立一个该自定义 operator 名称的 ServiceAccount</li><li>  <strong>deploy/role.yaml</strong>: 建立一个 role 定义它能存取 K8s cluster 的规则</li><li>  <strong>deploy/role_binding.yaml</strong>: 把上面的 ServiceAccount 和 Role 绑定起来，使该 ServiceAccount 拥有这个 Role 定义的存取 rule</li><li>  <strong>deploy/operator.yaml</strong>: 是 deploy operator 到 K8s cluster 上的 deployment，使用的 ServiceAccount 是我们 <code>deploy/service_account.yaml</code> 定义的名称</li><li>  <strong>deploy/crds/GROUP_VERSION_CRDNAME_crd.yaml</strong>: 就是我們自己定义 resource type，More detail: <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/">Extend the Kubernetes API with CustomResourceDefinitions</a></li><li>  <strong>deploy/crds/GROUP_VERSION_CRDNAME_cr.yaml</strong>: 是我们要 deploy 自定义的 resource，CR 代表 Custom Resource ，More detail: <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#create-custom-objects">Create custom objects</a> ，该文件中的 spec 就是完全复制 <code>helm-charts</code> 下的 values.yaml，所以原本用 helm 怎么定义 values.yaml 中的值，该文件中就怎么写</li></ul><pre><code class="hljs bash"><span class="hljs-comment"># 建立Service Account</span>$ kubectl create -f deploy/service_account.yaml<span class="hljs-comment"># 建立RBAC</span>$ kubectl create -f deploy/role.yaml$ kubectl create -f deploy/role_binding.yaml<span class="hljs-comment"># 建立CRD</span>$ kubectl create -f deploy/crds/app_v1alpha1_appservice_crd.yaml<span class="hljs-comment"># 部署app-operator</span><span class="hljs-comment"># 这里部署时，由于自动生成的 operator.yaml 文件中的 拉取镜像，默认为 imagePullPolicy: Always ；到镜像仓库拉取</span><span class="hljs-comment"># 我一般镜像打包到本地，所以替换为  imagePullPolicy: IfNotPresent ；本地有，就不到镜像仓库拉取</span>$ kubectl create -f deploy/operator.yaml<span class="hljs-comment"># 创建一个AppService用户资源</span><span class="hljs-comment"># 默认控制器将监视AppService对象并为每一个CR创建一个pod</span>$ kubectl create -f deploy/crds/app_v1alpha1_appservice_cr.yaml<span class="hljs-comment"># 验证pod是否创建</span>$ kubectl get pod -l app=example-appserviceNAME                     READY     STATUS    RESTARTS   AGEexample-appservice-pod   1/1       Running   0          1m</code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这样通过 <code>operator-framework/operator-sdk </code> 要完成自己的 CRD 和 operator 真的很快速和方便，可以预见，如果是开发或运维人员，在了解需求后，可以不用写很多的 operator 复杂和繁琐的重复程序，就可以快速开发和部署 operator ，且后续一样可以很方便的使用 K8s 的 API 资源；不过，是否要使用 <code>operator-framework/operator-sdk</code> ，一切还是需要自行的评估和结合当前应用服务的体量来看是否适合使用，小心服用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;  本篇介绍了CoreOS（已被红帽收购）的开源项目 &lt;a href=&quot;https://github.com/op</summary>
      
    
    
    
    <category term="技术加油站" scheme="https://liei.cc/blog/categories/%E6%8A%80%E6%9C%AF%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    
    
    <category term="Cloud Navite" scheme="https://liei.cc/blog/tags/cloud-navite/"/>
    
    <category term="Kubernetes" scheme="https://liei.cc/blog/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Select -- 无阻塞读写 channel</title>
    <link href="https://liei.cc/2019/go-channel-select.html"/>
    <id>https://liei.cc/2019/go-channel-select.html</id>
    <published>2019-02-02T06:15:15.000Z</published>
    <updated>2019-02-02T06:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通道阻塞"><a href="#通道阻塞" class="headerlink" title="通道阻塞"></a>通道阻塞</h2><p>在之前的 <a href="https://leeif.me/2019/01/go-concurrent-model.html"><strong>Go 的并发模型</strong></a> 可以了解到，FAN 流水模型可以多个 Goroutine 读一个 Channel 中的数据(FAN-OUT)，或者多个 Chanel 将数据发送到一个 Goroutine 中接收(FAN-IN)，<strong>但是无论是无缓冲通道，还是有缓冲通道，都存在阻塞的情况</strong></p><h3 id="无缓冲通道"><a href="#无缓冲通道" class="headerlink" title="无缓冲通道"></a>无缓冲通道</h3><blockquote><p>特点：发送的数据需要被读取后，发送才会完成</p></blockquote><p><strong>阻塞场景：</strong></p><ul><li>通道中无数据，但执行都通道</li><li>通道中无数据，向通道中写数据，但无其他协程读取该通道中的数据</li></ul><p><strong>代码示例：</strong></p><pre><code class="hljs go"><span class="hljs-comment">// 场景 1</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadNoDataFromNoBufCh</span><span class="hljs-params">()</span></span>&#123;    noBufCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)    <span class="hljs-comment">// 通道中无数据</span>    &lt;- noBufCh    fmt.Println(<span class="hljs-string">&quot;read from no buffer channel success&quot;</span>)    <span class="hljs-comment">// Output:</span>    <span class="hljs-comment">// fatal error: all goroutines are asleep - deadlock!</span>&#125;<span class="hljs-comment">// 场景 2</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteNoBufCh</span><span class="hljs-params">()</span></span>&#123;    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)    ch &lt;- <span class="hljs-number">1</span>    fmt.Println(<span class="hljs-string">&quot;write success no block&quot;</span>)    <span class="hljs-comment">// Output:</span>    <span class="hljs-comment">// fatal error: all goroutines are asleep - deadlock!</span>&#125;</code></pre><h3 id="有缓冲通道"><a href="#有缓冲通道" class="headerlink" title="有缓冲通道"></a>有缓冲通道</h3><blockquote><p>特点：有缓存时可以向通道中写入数据后直接返回，缓存中有数据时可以从通道中读到数据直接返回，这时有缓存通道是不会阻塞的</p></blockquote><p><strong>阻塞场景：</strong></p><ul><li>通道的缓存无数据，但执行读通道</li><li>通道的缓存已经占满，向通道写数据，但无协程读</li></ul><p><strong>代码示例：</strong></p><pre><code class="hljs go"><span class="hljs-comment">// 场景 1</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadNoDataFromBufCh</span><span class="hljs-params">()</span></span>&#123;    bufCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">1</span>)    <span class="hljs-comment">// 通道中无数据</span>    &lt;- bufCh    fmt.Println(<span class="hljs-string">&quot;read from no buffer channel success&quot;</span>)    <span class="hljs-comment">// Output:</span>    <span class="hljs-comment">// fatal error: all goroutines are asleep - deadlock!</span>&#125;<span class="hljs-comment">// 场景 2</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteBufChButFull</span><span class="hljs-params">()</span></span>&#123;    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">1</span>)    <span class="hljs-comment">// 写数据，占满缓冲</span>    ch &lt;- <span class="hljs-number">1</span>        <span class="hljs-comment">// 无协程读取缓冲中的数据，继续写，阻塞</span>    ch &lt;- <span class="hljs-number">2</span>    fmt.Println(<span class="hljs-string">&quot;write success no block&quot;</span>)    <span class="hljs-comment">// Output:</span>    <span class="hljs-comment">// fatal error: all goroutines are asleep - deadlock!</span>&#125;</code></pre><h2 id="Select-功能"><a href="#Select-功能" class="headerlink" title="Select 功能"></a>Select 功能</h2><p><strong>Select</strong> 由关键字 <code>select</code> 和 <code>case</code> 组成，<code>default</code> 不是必须的，如果没其他事可做，可以省略 <code>default</code>，<strong>在多个通道上进行读或写操作，让函数可以处理多个事情，但 1 次只处理 1 个</strong>，有以下特性：</p><ul><li>每次执行 <code>select</code>，都会只执行其中 1 个 <code>case</code> 或者执行 <code>default</code> 语句</li><li>当没有 case 或者 default 可以执行时，select 则阻塞，等待直到有 1 个 case 可以执行</li><li>当有多个 case 可以执行时，则随机选择 1 个 case 执行</li><li>case 后面跟的必须是读或者写通道的操作，否则编译出错</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;通道阻塞&quot;&gt;&lt;a href=&quot;#通道阻塞&quot; class=&quot;headerlink&quot; title=&quot;通道阻塞&quot;&gt;&lt;/a&gt;通道阻塞&lt;/h2&gt;&lt;p&gt;在之前的 &lt;a href=&quot;https://leeif.me/2019/01/go-concurrent-model.htm</summary>
      
    
    
    
    <category term="设计开发" scheme="https://liei.cc/blog/categories/%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go" scheme="https://liei.cc/blog/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Kuberntes 创建 LoadBalancer 类型服务</title>
    <link href="https://liei.cc/2019/k8s-deploy-metallb-LoadBalancer.html"/>
    <id>https://liei.cc/2019/k8s-deploy-metallb-LoadBalancer.html</id>
    <published>2019-02-01T06:15:15.000Z</published>
    <updated>2019-02-01T06:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>我们知道，Service 机制，以及 Kubernetes 里的 DNS 插件，都是在帮助我们解决同样一个问题，即：如何找到某一个容器；而 Service 是由 kube-proxy 组件，加上 iptables 来共同实现的；所谓 Service 的访问入口，其实就是每台宿主机上由 kube-proxy 生成的 iptables 规则，以及 kube-dns 生成的 DNS 记录。而一旦离开了这个集群，这些信息对用户来说，也就自然没有作用了</p></blockquote><p>在使用 Kubernetes 的 Service 时，一个必须要面对和解决的问题就是：<strong>如何从外部（Kubernetes 集群之外），访问到 Kubernetes 里创建的 Service？</strong></p><h2 id="从外界连通-Service"><a href="#从外界连通-Service" class="headerlink" title="从外界连通 Service"></a>从外界连通 Service</h2><h3 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h3><ul><li>NodePort</li><li>ExternalIP</li><li>LoadBalance</li></ul><p>这里 <code>NodePort</code> 和 <code>externalIPs</code> 是 K8S 集群本身就支持的特性，这两个方案让很多私有云用户成为了 K8S 世界中的二等公民，而 <code>NodePort</code> 也是我们最常用的；</p><p>而 kubernetes  没有为裸机群集提供网络负载均衡器（类型为 <code>LoadBalancer</code> 的服务）的实现，如果你的 K8S 集群没有在公有云的 IaaS 平台（GCP，AWS，Azure …）上运行，则 LoadBalancers 将在创建时无限期地保持 “挂起” 状态，也就是说只有公有云厂商自家的 kubernetes 支持 LoadBalancer，对 LoadBalancer 类型的服务的支持应该是众多表面差异中最醒目的一个了</p><h3 id="纯软件解决方案-MetalLB"><a href="#纯软件解决方案-MetalLB" class="headerlink" title="纯软件解决方案: MetalLB"></a>纯软件解决方案: MetalLB</h3><blockquote><p>该项目发布于 2017 年底，当前处于 Beta 阶段，旨在解决上述中的不平衡，通过提供与标准网络设备集成的网络 LB 实现来纠正这种不平衡，以便裸机集群上的外部服务也 “尽可能” 地工作；即 MetalLB 能够帮助你在 kubernetes 中创建 LoadBalancer 类型的 kubernetes 服务</p><p>项目地址：<a href="https://github.com/google/metallb">https://github.com/google/metallb</a></p><p>版本说明：<a href="https://metallb.universe.tf/release-notes/">https://metallb.universe.tf/release-notes/</a></p></blockquote><p><code>Metallb</code> 会在 Kubernetes 内运行，监控服务对象的变化，一旦察觉有新的 LoadBalancer 服务运行，并且没有可申请的负载均衡器之后，就会完成两部分的工作：</p><ul><li><p><strong>地址分配</strong></p><p>用户需要在配置中提供一个地址池，Metallb 将会在其中选取地址分配给服务。</p></li><li><p><strong>地址广播</strong></p><p>根据不同配置，Metallb 会以二层（ARP/NDP）或者 BGP 的方式进行地址的广播</p></li></ul><p><img src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/2019/metallb.jpg" alt="基本原理图"></p><h2 id="安装部署演示"><a href="#安装部署演示" class="headerlink" title="安装部署演示"></a>安装部署演示</h2><h3 id="部署-Metallb-负载均衡器"><a href="#部署-Metallb-负载均衡器" class="headerlink" title="部署 Metallb 负载均衡器"></a>部署 Metallb 负载均衡器</h3><p>Metallb 支持 Helm 和 YAML 两种安装方法(这里推荐第二种)</p><ul><li><p>Helm</p><pre><code class="hljs sh">$ helm install --name metallb stable/metallb</code></pre></li><li><p>YAML</p><pre><code class="hljs bash">$ kubectl apply -f https://raw.githubusercontent.com/google/metallb/v0.7.3/manifests/metallb.yaml</code></pre></li></ul><p>很简单，<code>Metallb</code> 就会开始安装，会生成自己的命名空间以及 RBAC 配置</p><pre><code class="hljs sh">[root@lee ~]<span class="hljs-comment"># kubectl apply -f https://raw.githubusercontent.com/google/metallb/v0.7.3/manifests/metallb.yaml</span>namespace/metallb-system createdserviceaccount/controller createdserviceaccount/speaker createdclusterrole.rbac.authorization.k8s.io/metallb-system:controller createdclusterrole.rbac.authorization.k8s.io/metallb-system:speaker createdrole.rbac.authorization.k8s.io/config-watcher createdclusterrolebinding.rbac.authorization.k8s.io/metallb-system:controller createdclusterrolebinding.rbac.authorization.k8s.io/metallb-system:speaker createdrolebinding.rbac.authorization.k8s.io/config-watcher createddaemonset.apps/speaker createddeployment.apps/controller created[root@lee ~]<span class="hljs-comment"># kubectl get pods -n metallb-system -owide</span>NAME                                             READY   STATUS  RESTARTS   AGE   IP               NODE   NOMINATED NODEcontroller-765899887-bdwdk   1/1     Running   0          82s   10.0.0.22                lee    &lt;none&gt;speaker-qldl6                                  1/1     Running   0          82s   192.168.50.124   lee    &lt;none&gt;</code></pre><p>目前还没有宣布任何内容，因为我们没有提供 ConfigMap，也没有提供负载均衡地址的服务；<br>接下来我们要生成一个 ConfigMap文件，为 Metallb 设置网址范围以及协议相关的选择和配置</p><h3 id="提供-IP-pool"><a href="#提供-IP-pool" class="headerlink" title="提供 IP pool"></a>提供 IP pool</h3><p>通过之前提到的原理图可知，需要创建一个 <code>ConfigMap</code> 文件，以提供 <code>IP 池</code>；</p><pre><code class="hljs sh">$ wget https://raw.githubusercontent.com/google/metallb/v0.7.3/manifests/example-layer2-config.yaml</code></pre><p><strong>修改 ip 地址池和集群节点网段相同，且必须为一个 IP 区间</strong></p><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">metallb-system</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><span class="hljs-attr">data:</span>  <span class="hljs-attr">config:</span> <span class="hljs-string">|</span>    <span class="hljs-attr">address-pools:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-ip-space</span>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">layer2</span>      <span class="hljs-attr">addresses:</span>      <span class="hljs-comment"># 与集群节点网段相同</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.50</span><span class="hljs-number">.211</span><span class="hljs-number">-192.168</span><span class="hljs-number">.50</span><span class="hljs-number">.220</span></code></pre><p>**IP 地址为 <code>无占用</code> **</p><pre><code class="hljs bash">[root@lee ~]<span class="hljs-comment"># ping 192.168.50.211</span>PING 192.168.50.211 (192.168.50.211) 56(84) bytes of data.From 192.168.50.124 icmp_seq=1 Destination Host UnreachableFrom 192.168.50.124 icmp_seq=2 Destination Host UnreachableFrom 192.168.50.124 icmp_seq=3 Destination Host UnreachableFrom 192.168.50.124 icmp_seq=4 Destination Host Unreachable^C--- 192.168.50.211 ping statistics ---5 packets transmitted, 0 received, +4 errors, 100% packet loss, time 4001ms</code></pre><p>部署 <code>example-layer2-config.yaml</code> 文件</p><pre><code class="hljs sh">$ kubectl apply -f example-layer2-config.yaml</code></pre><h3 id="部署应用服务测试"><a href="#部署应用服务测试" class="headerlink" title="部署应用服务测试"></a>部署应用服务测试</h3><pre><code class="hljs sh">$ wget https://raw.githubusercontent.com/google/metallb/master/manifests/tutorial-2.yaml$ kubectl apply -f tutorial-2.yaml</code></pre><p>查看 yaml 文件配置，包含了一个 deployment 和一个 LoadBalancer 类型的 service，默认即可；</p><p><strong>查看 service 分配的 EXTERNAL-IP</strong></p><pre><code class="hljs bash">[root@lee ~]<span class="hljs-comment"># kubectl get svc -owide</span>NAME               TYPE             CLUSTER-IP     EXTERNAL-IP         PORT(S)                 AGE   SELECTORnginx           LoadBalancer   10.0.228.36      192.168.50.211     80:31796/TCP        65s   app=nginx</code></pre><p>ping 该 <code> EXTERNAL-IP</code> 地址，发现该地址可以访问了</p><pre><code class="hljs sh">[root@lee ~]<span class="hljs-comment"># ping 192.168.50.211</span>PING 192.168.50.211 (192.168.50.211) 56(84) bytes of data.64 bytes from 192.168.50.211: icmp_seq=1 ttl=64 time=0.050 ms64 bytes from 192.168.50.211: icmp_seq=2 ttl=64 time=0.082 ms64 bytes from 192.168.50.211: icmp_seq=3 ttl=64 time=0.068 ms</code></pre><p>集群内访问该 <code> EXTERNAL-IP</code> 地址</p><pre><code class="hljs bash">[root@lee ~]<span class="hljs-comment"># curl 192.168.50.211</span>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;...............&lt;p&gt;&lt;em&gt;Thank you <span class="hljs-keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>从集群外访问该 IP 地址</p><pre><code class="hljs bash">Administrator at 16:47:09 / $ curl 192.168.50.211  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100   612  100   612    0     0   597k      0 --:--:-- --:--:-- --:--:--  597k&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;................&lt;p&gt;&lt;em&gt;Thank you <span class="hljs-keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>另外使用 <code>Node IP + NodePort</code> 也可以访问</p><pre><code class="hljs bash">Administrator at 16:47:09 / $ curl 192.168.50.124:31796  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100   612  100   612    0     0   597k      0 --:--:-- --:--:-- --:--:--  597k&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;................&lt;p&gt;&lt;em&gt;Thank you <span class="hljs-keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我们知道，Service 机制，以及 Kubernetes 里的 DNS 插件，都是在帮助我们解决同样一个问题，即</summary>
      
    
    
    
    <category term="解决方案" scheme="https://liei.cc/blog/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Cloud Navite" scheme="https://liei.cc/blog/tags/cloud-navite/"/>
    
    <category term="Kubernetes" scheme="https://liei.cc/blog/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Go 并发模型</title>
    <link href="https://liei.cc/2019/go-concurrent-model.html"/>
    <id>https://liei.cc/2019/go-concurrent-model.html</id>
    <published>2019-01-22T06:15:15.000Z</published>
    <updated>2019-01-22T06:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Go 语言是为并发而生的语言，Go 语言是为数不多的在语言层面实现并发的语言；也正是 Go 语言的并发特性，吸引了全球无数的开发者</p></blockquote><h2 id="并发-concurrency-和并行-parallellism"><a href="#并发-concurrency-和并行-parallellism" class="headerlink" title="并发 (concurrency) 和并行(parallellism)"></a>并发 (concurrency) 和并行(parallellism)</h2><p>在了解 <strong>Go</strong> 的并发原理之前，先了解什么是并发什么是并行；</p><ul><li><p>并发 <strong>( concurrency )</strong></p><p>两个或两个以上的任务在一段时间内被执行。我们不必 care 这些任务在某一个时间点是否是同时执行，可能同时执行，也可能不是，我们只关心在一段时间内，哪怕是很短的时间（一秒或者两秒）是否执行解决了两个或两个以上任务</p></li><li><p>并行  <strong>( parallellism )</strong></p><p>两个或两个以上的任务在同一时刻被同时执行</p></li></ul><p>并发说的是逻辑上的概念，而并行，强调的是物理运行状态；并发 “包含” 并行；( 详情请见：<strong>Rob Pike</strong> 的 <a href="https://talks.golang.org/2012/concurrency.slide#1">PPT</a>)</p><h2 id="CSP-并发模型"><a href="#CSP-并发模型" class="headerlink" title="CSP 并发模型"></a>CSP 并发模型</h2><p>Go 实现了两种并发形式。第一种是大家普遍认知的：多线程共享内存。其实就是 Java 或者 C++ 等语言中的多线程开发。另外一种是 Go 语言特有的，也是 Go 语言推荐的：<code>CSP</code>（communicating sequential processes）并发模型</p><p>请记住下面这句话：</p><blockquote><p><strong>Do not communicate by sharing memory; instead, share memory by communicating.</strong><br>“不要以共享内存的方式来通信，相反，要通过通信来共享内存”</p></blockquote><p>普通的线程并发模型，就是像 Java、C++、或者 Python，他们线程间通信都是通过共享内存的方式来进行的。非常典型的方式就是，在访问共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问，因此，在很多时候，衍生出一种方便操作的数据结构，叫做 “线程安全的数据结构”</p><p>Go 的 CSP 并发模型，是通过<code>goroutine</code>和<code>channel</code>来实现的。</p><ul><li><code>goroutine:</code> 是 Go 语言中并发的执行单位，有点抽象，其实就是和传统概念上的<code>线程 </code>类似，但它比线程更为轻量，称之为<code>协程</code></li><li><code>channel：</code> 是 Go 语言中各个并发结构体 (<code>goroutine</code>) 之前的通信机制。 通俗的讲，就是各个<code>goroutine</code>之间通信的” 管道 “，有点类似于 Linux 中的管道</li></ul><p>创建一个 <code>goroutine</code> 很简单，只要使用 <code>go</code> 关键字就可以了，如下；</p><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span></code></pre><p>通信机制 <code>channel</code> 也很方便，传数据用 <code>channel &lt;- data</code> ，取数据用 <code>&lt;-channel</code></p><p>在通信过程中，传数据 <code>channel &lt;- data</code> 和取数据 <code>&lt;-channel</code> 必然会成对出现，因为这边传，那边取，两个<code>goroutine</code>之间才会实现通信，而且不管传还是取，必阻塞，直到另外的<code>goroutine</code>传或者取为止</p><img src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/2019/go-cps.png"><p>这便是 <code>Golang CSP</code> 并发模型最基本的形式，本问内容不详细阐述并发原理</p><h2 id="并发模型的运用"><a href="#并发模型的运用" class="headerlink" title="并发模型的运用"></a>并发模型的运用</h2><h3 id="流水线模型"><a href="#流水线模型" class="headerlink" title="流水线模型"></a>流水线模型</h3><blockquote><p>Golang 并发核心思路是关注数据流动。数据流动的过程交给 channel，数据处理的每个环节都交给 goroutine，把这些流程画起来，有始有终形成一条线，那就能构成流水线模型</p></blockquote><p>流水线并不是什么新奇的概念，它能极大的提高生产效率，在当代社会流水线非常普遍，我们用的几乎任何产品（手机、电脑、汽车、水杯），都是从流水线上生产出来的；<strong>在 Golang 中，流水线由多个阶段组成，每个阶段之间通过 channel 连接，每个节点可以由多个同时运行的 goroutine 组成</strong></p><p><img src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/2019/20190124110810.png"></p><p>如上图，从最简单的流水线入手，由 3 个阶段组成，分别是 A、B、C；第一个阶段的协程是<strong>生产者</strong>，它们只生产数据，最后一个阶段的协程是<strong>消费者</strong>，A 是生成者，C 是消费者，而 B 只是中间过程的处理者；A 和 B 之间是通道<code>aCh</code>，B 和 C 之间是通道<code>bCh</code>，A 生成数据传递给 B，B 生成数据传递给 C</p><blockquote><p>举个例子，设计一个程序：计算一个整数切片中元素的平方值并把它打印出来。非并发的方式是使用 for 遍历整个切片，然后计算平方，打印结果</p></blockquote><p>我们使用流水线模型实现这个简单的功能，从流水线的角度，可以分为 3 个阶段：</p><ol><li>遍历切片，这是生产者。</li><li>计算平方值。</li><li>打印结果，这是消费者。</li></ol><p>具体代码，参考 <a href="https://github.com/leeifme/Go-test/blob/master/go-concurrent/assembly-line/simple.go"><strong>simple.go</strong></a></p><ul><li><code>producer()</code>负责生产数据，它会把数据写入通道，并把它写数据的通道返回</li><li><code>square()</code>负责从某个通道读数字，然后计算平方，将结果写入通道，并把它的输出通道返回</li><li><code>main()</code>负责启动 producer 和 square，并且还是消费者，读取 suqre 的结果，并打印出来</li></ul><p><strong>流水线的特点</strong></p><ol><li>每个阶段把数据通过 channel 传递给下一个阶段</li><li>每个阶段要创建 1 个 goroutine 和 1 个通道，这个 goroutine 向里面写数据，函数要返回这个通道</li><li>有 1 个函数来组织流水线，我们例子中是 main 函数</li></ol><h3 id="流水线-FAN-模式"><a href="#流水线-FAN-模式" class="headerlink" title="流水线 FAN 模式"></a>流水线 FAN 模式</h3><blockquote><p>流水线模型进阶，FAN-IN 和 FAN-OUT 模式，FAN 模式可以让我们的流水线模型更好的利用 Golang 并发，提高软件性能</p></blockquote><p>这里还是以生产汽车的流水线为例，汽车生产线上有个阶段是给小汽车装 4 个轮子，可以把这个阶段任务交给 4 个人同时去做，这 4 个人把轮子都装完后，再把汽车移动到生产线下一个阶段；这个过程中，就有任务的分发，和任务结果的收集；<strong>其中任务分发是 FAN-OUT，任务收集是 FAN-IN</strong></p><ul><li><strong>FAN-OUT 模式：多个 goroutine 从同一个通道读取数据，直到该通道关闭；</strong>OUT 是一种张开的模式，所以又被称为扇出，可以用来分发任务</li><li><strong>FAN-IN 模式：1 个 goroutine 从多个通道读取数据，直到这些通道关闭；</strong>IN 是一种收敛的模式，所以又被称为扇入，用来收集处理的结果</li></ul><p>如下图所示，</p><p><img src="https://leeifme.oss-cn-shanghai.aliyuncs.com/blog/2019/20190124112954.png"></p><p>依然延用上面的案例需求，计算一个整数切片中元素的平方值并把它打印出来，这次我们修改一下，添加 <code>merge()</code> 方法，具体代码参考 <a href="https://github.com/leeifme/Go-test/blob/master/go-concurrent/assembly-line/fan.go"><strong>fan.go</strong></a></p><ul><li><code>producer()</code>保持不变，负责生产数据</li><li><code>squre()</code>也不变，负责计算平方值</li><li>修改<code>main()</code>，启动 3 个 square，这 3 个 squre 从 producer 生成的通道读数据，<strong>这是 FAN-OUT</strong></li><li>增加<code>merge()</code>，入参是 3 个 square 各自写数据的通道，给这 3 个通道分别启动 1 个协程，把数据写入到自己创建的通道，并返回该通道，<strong>这是 FAN-IN</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Go 语言是为并发而生的语言，Go 语言是为数不多的在语言层面实现并发的语言；也正是 Go 语言的并发特性，吸引了</summary>
      
    
    
    
    <category term="设计开发" scheme="https://liei.cc/blog/categories/%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go" scheme="https://liei.cc/blog/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>VS Code 常用快捷键整理</title>
    <link href="https://liei.cc/2018/vscode-hotkey-record.html"/>
    <id>https://liei.cc/2018/vscode-hotkey-record.html</id>
    <published>2018-12-01T12:36:25.000Z</published>
    <updated>2018-12-01T12:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl + Shift + P，F1</td><td>显示命令面板 Show Command Palette</td></tr><tr><td>Ctrl + P</td><td>快速打开 Quick Open</td></tr><tr><td>Ctrl + Shift + N</td><td>新窗口 / 实例 New window/instance</td></tr><tr><td>Ctrl + Shift + W</td><td>关闭窗口 / 实例 Close window/instance</td></tr></tbody></table><h2 id="基础编辑-Basic-editing"><a href="#基础编辑-Basic-editing" class="headerlink" title="基础编辑 Basic editing"></a>基础编辑 Basic editing</h2><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl+X</td><td>剪切行（空选定） Cut line (empty selection)</td></tr><tr><td>Ctrl+C</td><td>复制行（空选定）Copy line (empty selection)</td></tr><tr><td>Alt+ ↑ / ↓</td><td>向上 / 向下移动行 Move line up/down</td></tr><tr><td>Shift+Alt + ↓ / ↑</td><td>向上 / 向下复制行 Copy line up/down</td></tr><tr><td>Ctrl+Shift+K</td><td>删除行 Delete line</td></tr><tr><td>Ctrl+Enter</td><td>在下面插入行 Insert line below</td></tr><tr><td>Ctrl+Shift+Enter</td><td>在上面插入行 Insert line above</td></tr><tr><td>Ctrl+Shift+\</td><td>跳到匹配的括号 Jump to matching bracket</td></tr><tr><td>Ctrl+] / [</td><td>缩进 / 缩进行 Indent/outdent line</td></tr><tr><td>Home</td><td>转到行首 Go to beginning of line</td></tr><tr><td>End</td><td>转到行尾 Go to end of line</td></tr><tr><td>Ctrl+Home</td><td>转到文件开头 Go to beginning of file</td></tr><tr><td>Ctrl+End</td><td>转到文件末尾 Go to end of file</td></tr><tr><td>Ctrl+↑ / ↓</td><td>向上 / 向下滚动行 Scroll line up/down</td></tr><tr><td>Alt+PgUp / PgDown</td><td>向上 / 向下滚动页面 Scroll page up/down</td></tr><tr><td>Ctrl+Shift+[</td><td>折叠（折叠）区域 Fold (collapse) region</td></tr><tr><td>Ctrl+Shift+]</td><td>展开（未折叠）区域 Unfold (uncollapse) region</td></tr><tr><td>Ctrl+K Ctrl+[</td><td>折叠（未折叠）所有子区域 Fold (collapse) all subregions</td></tr><tr><td>Ctrl+K Ctrl+]</td><td>展开（未折叠）所有子区域 Unfold (uncollapse) all subregions</td></tr><tr><td>Ctrl+K Ctrl+0</td><td>折叠（折叠）所有区域 Fold (collapse) all regions</td></tr><tr><td>Ctrl+K Ctrl+J</td><td>展开（未折叠）所有区域 Unfold (uncollapse) all regions</td></tr><tr><td>Ctrl+K Ctrl+C</td><td>添加行注释 Add line comment</td></tr><tr><td>Ctrl+K Ctrl+U</td><td>删除行注释 Remove line comment</td></tr><tr><td>Ctrl+/</td><td>切换行注释 Toggle line comment</td></tr><tr><td>Shift+Alt+A</td><td>切换块注释 Toggle block comment</td></tr><tr><td>Alt+Z</td><td>切换换行 Toggle word wrap</td></tr></tbody></table><h2 id="导航-Navigation"><a href="#导航-Navigation" class="headerlink" title="导航 Navigation"></a>导航 Navigation</h2><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl + T</td><td>显示所有符号 Show all Symbols</td></tr><tr><td>Ctrl + G</td><td>转到行… Go to Line…</td></tr><tr><td>Ctrl + P</td><td>转到文件… Go to File…</td></tr><tr><td>Ctrl + Shift + O</td><td>转到符号… Go to Symbol…</td></tr><tr><td>Ctrl + Shift + M</td><td>显示问题面板 Show Problems panel</td></tr><tr><td>F8</td><td>转到下一个错误或警告 Go to next error or warning</td></tr><tr><td>Shift + F8</td><td>转到上一个错误或警告 Go to previous error or warning</td></tr><tr><td>Ctrl + Shift + Tab</td><td>导航编辑器组历史记录 Navigate editor group history</td></tr><tr><td>Alt + ←/→</td><td>返回 / 前进 Go back / forward</td></tr><tr><td>Ctrl + M</td><td>切换选项卡移动焦点 Toggle Tab moves focus</td></tr></tbody></table><h2 id="搜索和替换-Search-and-replace"><a href="#搜索和替换-Search-and-replace" class="headerlink" title="搜索和替换 Search and replace"></a>搜索和替换 Search and replace</h2><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl + F</td><td>查找 Find</td></tr><tr><td>Ctrl + H</td><td>替换 Replace</td></tr><tr><td>F3 / Shift + F3</td><td>查找下一个 / 上一个 Find next/previous</td></tr><tr><td>Alt + Enter</td><td>选择查找匹配的所有出现 Select all occurences of Find match</td></tr><tr><td>Ctrl + D</td><td>将选择添加到下一个查找匹配 Add selection to next Find match</td></tr><tr><td>Ctrl + K Ctrl + D</td><td>将最后一个选择移至下一个查找匹配项 Move last selection to next Find match</td></tr><tr><td>Alt + C / R / W</td><td>切换区分大小写 / 正则表达式 / 整个词 Toggle case-sensitive / regex / whole word</td></tr></tbody></table><h2 id="多光标和选择-Multi-cursor-and-selection"><a href="#多光标和选择-Multi-cursor-and-selection" class="headerlink" title="多光标和选择 Multi-cursor and selection"></a>多光标和选择 Multi-cursor and selection</h2><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Alt + 单击</td><td>插入光标 Insert cursor</td></tr><tr><td>Ctrl + Alt +↑/↓</td><td>在上 / 下插入光标 Insert cursor above / below</td></tr><tr><td>Ctrl + U</td><td>撤消上一个光标操作 Undo last cursor operation</td></tr><tr><td>Shift + Alt + I</td><td>在选定的每一行的末尾插入光标 Insert cursor at end of each line selected</td></tr><tr><td>Ctrl + I</td><td>选择当前行 Select current line</td></tr><tr><td>Ctrl + Shift + L</td><td>选择当前选择的所有出现 Select all occurrences of current selection</td></tr><tr><td>Ctrl + F2</td><td>选择当前字的所有出现 Select all occurrences of current word</td></tr><tr><td>Shift + Alt + →</td><td>展开选择 Expand selection</td></tr><tr><td>Shift + Alt + ←</td><td>缩小选择 Shrink selection</td></tr><tr><td>Shift + Alt + （拖动鼠标）</td><td>列（框）选择 Column (box) selection</td></tr><tr><td>Ctrl + Shift + Alt +（箭头键）</td><td>列（框）选择 Column (box) selection</td></tr><tr><td>Ctrl + Shift + Alt + PgUp / PgDown</td><td>列（框）选择页上 / 下 Column (box) selection page up/down</td></tr></tbody></table><h2 id="丰富的语言编辑-Rich-languages-editing"><a href="#丰富的语言编辑-Rich-languages-editing" class="headerlink" title="丰富的语言编辑 Rich languages editing"></a>丰富的语言编辑 Rich languages editing</h2><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl + 空格</td><td>触发建议 Trigger suggestion</td></tr><tr><td>Ctrl + Shift + Space</td><td>触发器参数提示 Trigger parameter hints</td></tr><tr><td>Tab</td><td>Emmet 展开缩写 Emmet expand abbreviation</td></tr><tr><td>Shift + Alt + F</td><td>格式化文档 Format document</td></tr><tr><td>Ctrl + K Ctrl + F</td><td>格式选定区域 Format selection</td></tr><tr><td>F12</td><td>转到定义 Go to Definition</td></tr><tr><td>Alt + F12</td><td>Peek 定义 Peek Definition</td></tr><tr><td>Ctrl + K F12</td><td>打开定义到边 Open Definition to the side</td></tr><tr><td>Ctrl + .</td><td>快速解决 Quick Fix</td></tr><tr><td>Shift + F12</td><td>显示引用 Show References</td></tr><tr><td>F2</td><td>重命名符号 Rename Symbol</td></tr><tr><td>Ctrl + Shift + . /，</td><td>替换为下一个 / 上一个值 Replace with next/previous value</td></tr><tr><td>Ctrl + K Ctrl + X</td><td>修剪尾随空格 Trim trailing whitespace</td></tr><tr><td>Ctrl + K M</td><td>更改文件语言 Change file language</td></tr></tbody></table><h2 id="编辑器管理-Editor-management"><a href="#编辑器管理-Editor-management" class="headerlink" title="编辑器管理 Editor management"></a>编辑器管理 Editor management</h2><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl+F4, Ctrl+W</td><td>关闭编辑器 Close editor</td></tr><tr><td>Ctrl+K F</td><td>关闭文件夹 Close folder</td></tr><tr><td>Ctrl+\</td><td>拆分编辑器 Split editor</td></tr><tr><td>Ctrl+ 1 / 2 / 3</td><td>聚焦到第 1，第 2 或第 3 编辑器组 Focus into 1st, 2nd or 3rd editor group</td></tr><tr><td>Ctrl+K Ctrl+ ←/→</td><td>聚焦到上一个 / 下一个编辑器组 Focus into previous/next editor group</td></tr><tr><td>Ctrl+Shift+PgUp / PgDown</td><td>向左 / 向右移动编辑器 Move editor left/right</td></tr><tr><td>Ctrl+K ← / →</td><td>移动活动编辑器组 Move active editor group</td></tr></tbody></table><h2 id="文件管理-File-management"><a href="#文件管理-File-management" class="headerlink" title="文件管理 File management"></a>文件管理 File management</h2><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl+N</td><td>新文件 New File</td></tr><tr><td>Ctrl+O</td><td>打开文件… Open File…</td></tr><tr><td>Ctrl+S</td><td>保存 Save</td></tr><tr><td>Ctrl+Shift+S</td><td>另存为… Save As…</td></tr><tr><td>Ctrl+K S</td><td>全部保存 Save All</td></tr><tr><td>Ctrl+F4</td><td>关闭 Close</td></tr><tr><td>Ctrl+K Ctrl+W</td><td>关闭所有 Close All</td></tr><tr><td>Ctrl+Shift+T</td><td>重新打开关闭的编辑器 Reopen closed editor</td></tr><tr><td>Ctrl+K</td><td>输入保持打开 Enter Keep Open</td></tr><tr><td>Ctrl+Tab</td><td>打开下一个 Open next</td></tr><tr><td>Ctrl+Shift+Tab</td><td>打开上一个 Open previous</td></tr><tr><td>Ctrl+K P</td><td>复制活动文件的路径 Copy path of active file</td></tr><tr><td>Ctrl+K R</td><td>显示资源管理器中的活动文件 Reveal active file in Explorer</td></tr><tr><td>Ctrl+K O</td><td>显示新窗口 / 实例中的活动文件 Show active file in new window/instance</td></tr></tbody></table><h2 id="显示-Display"><a href="#显示-Display" class="headerlink" title="显示 Display"></a>显示 Display</h2><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>F11</td><td>切换全屏 Toggle full screen</td></tr><tr><td>Shift+Alt+1</td><td>切换编辑器布局 Toggle editor layout</td></tr><tr><td>Ctrl+ = / -</td><td>放大 / 缩小 Zoom in/out</td></tr><tr><td>Ctrl+B</td><td>切换侧栏可见性 Toggle Sidebar visibility</td></tr><tr><td>Ctrl+Shift+E</td><td>显示浏览器 / 切换焦点 Show Explorer / Toggle focus</td></tr><tr><td>Ctrl+Shift+F</td><td>显示搜索 Show Search</td></tr><tr><td>Ctrl+Shift+G</td><td>显示 Git Show Git</td></tr><tr><td>Ctrl+Shift+D</td><td>显示调试 Show Debug</td></tr><tr><td>Ctrl+Shift+X</td><td>显示扩展 Show Extensions</td></tr><tr><td>Ctrl+Shift+H</td><td>替换文件 Replace in files</td></tr><tr><td>Ctrl+Shift+J</td><td>切换搜索详细信息 Toggle Search details</td></tr><tr><td>Ctrl+Shift+C</td><td>打开新命令提示符 / 终端 Open new command prompt/terminal</td></tr><tr><td>Ctrl+Shift+U</td><td>显示输出面板 Show Output panel</td></tr><tr><td>Ctrl+Shift+V</td><td>切换 Markdown 预览 Toggle Markdown preview</td></tr><tr><td>Ctrl+K V</td><td>从旁边打开 Markdown 预览 Open Markdown preview to the side</td></tr></tbody></table><h2 id="调试-Debug"><a href="#调试-Debug" class="headerlink" title="调试 Debug"></a>调试 Debug</h2><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>F9</td><td>切换断点 Toggle breakpoint</td></tr><tr><td>F5</td><td>开始 / 继续 Start/Continue</td></tr><tr><td>Shift+F5</td><td>停止 Stop</td></tr><tr><td>F11 / Shift+F11</td><td>下一步 / 上一步 Step into/out</td></tr><tr><td>F10</td><td>跳过 Step over</td></tr><tr><td>Ctrl+K Ctrl+I</td><td>显示悬停 Show hover</td></tr></tbody></table><h2 id="集成终端-Integrated-terminal"><a href="#集成终端-Integrated-terminal" class="headerlink" title="集成终端 Integrated terminal"></a>集成终端 Integrated terminal</h2><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl+`</td><td>显示集成终端 Show integrated terminal</td></tr><tr><td>Ctrl+Shift+`</td><td>创建新终端 Create new terminal</td></tr><tr><td>Ctrl+Shift+C</td><td>复制选定 Copy selection</td></tr><tr><td>Ctrl+Shift+V</td><td>粘贴到活动端子 Paste into active terminal</td></tr><tr><td>Ctrl+↑ / ↓</td><td>向上 / 向下滚动 Scroll up/down</td></tr><tr><td>Shift+PgUp / PgDown</td><td>向上 / 向下滚动页面 Scroll page up/down</td></tr><tr><td>Ctrl+Home / End</td><td>滚动到顶部 / 底部 Scroll to top/bottom</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;按 Press&lt;/th&gt;
&lt;th&gt;功能 Function&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + P，F1&lt;/td&gt;
&lt;td&gt;显示命令面板 Show Command P</summary>
      
    
    
    
    <category term="安利系列" scheme="https://liei.cc/blog/categories/%E5%AE%89%E5%88%A9%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="VSCode" scheme="https://liei.cc/blog/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>简化 Kubernetes 应用部署工具 -- Helm</title>
    <link href="https://liei.cc/2018/k8s-deploy-tool-helm.html"/>
    <id>https://liei.cc/2018/k8s-deploy-tool-helm.html</id>
    <published>2018-11-10T06:15:15.000Z</published>
    <updated>2018-11-10T06:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先区分下概念"><a href="#先区分下概念" class="headerlink" title="先区分下概念"></a>先区分下概念</h3><ul><li><strong><code>Docker</code></strong>: 镜像是把一个单纯的 App 和它的安装环境整合在一起。</li><li><strong><code>Kubertnetes</code></strong>: 管理 Docker 容器的生成和毁灭，保证 Docker 容器对应 App 的高可用（监控、自动创建）和易维护（部署和对外暴露、动态扩容、启动停止删除等）。</li><li><strong><code>Helm</code></strong>: 是为了方便配置和部署、升级和回滚应用，尤其是多个 Service 组合创建的一个大型应用，比如网站</li></ul><h3 id="为什么要用？"><a href="#为什么要用？" class="headerlink" title="为什么要用？"></a>为什么要用？</h3><blockquote><p>首先在原来项目中都是基于 yaml 文件来进行部署发布的，而目前项目大部分微服务化或者模块化，会分成很多个组件来部署，每个组件可能对应一个 deployment.yaml, 一个 service.yaml, 一个 Ingress.yaml 还可能存在各种依赖关系，这样一个项目如果有 5 个组件，很可能就有 15 个不同的 yaml 文件，这些 yaml 分散存放，如果某天进行项目恢复的话，很难知道部署顺序，依赖关系等，而所有这些包括</p><ul><li>基于 yaml 配置的集中存放</li><li>基于项目的打包</li><li>组件间的依赖</li></ul><p>都可以通过 helm 来进行解决</p></blockquote><h3 id="Helm-基本概念"><a href="#Helm-基本概念" class="headerlink" title="Helm 基本概念"></a>Helm 基本概念</h3><blockquote><p>Helm 可以理解为 Kubernetes 的包管理工具，可以方便地发现、共享和使用为 Kubernetes 构建的应用，它包含几个基本概念</p><ul><li>Chart：一个 Helm 包，其中包含了运行一个应用所需要的镜像、依赖和资源定义等，还可能包含 Kubernetes 集群中的服务定义</li><li>Release: 在 Kubernetes 集群上运行的 Chart 的一个实例。在同一个集群上，一个 Chart 可以安装很多次每次安装都会创建一个新的 release。例如一个 MySQL Chart，如果想在服务器上运行两个数据库，就可以把这个 Chart 安装两次。每次安装都会生成自己的 Release，会有自己的 Release 名称</li><li>Repository：用于发布和存储 Chart 的仓库</li></ul></blockquote><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul><li>Helm 是一个 Chart 管理器: <a href="https://github.com/kubernetes/helm">GitHub - kubernetes/helm: The Kubernetes Package Manager</a></li><li>Charts 是一组配置好的 Kubernetes 资源（定义）组合</li><li>Release 是一组已经部署到 Kubernetes 上的资源集合</li></ul><h4 id="Chart-的基本结构"><a href="#Chart-的基本结构" class="headerlink" title="Chart 的基本结构"></a>Chart 的基本结构</h4><pre><code class="hljs plain">.├── Chart.yaml├── README.md├── templates│   ├── NOTES.txt│   ├── _helpers.tpl│   ├── deployment.yaml│   ├── pvc.yaml│   ├── secrets.yaml│   └── svc.yaml└── values.yaml</code></pre><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ol><li>创建可配置的 Release</li><li>升级、删除、查看由 Helm 创建的 Release</li></ol><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ol><li><strong><code>Helm Client</code></strong> 客户端<ul><li>制作、拉取、查找和验证 Chart</li><li>安装服务端 Tiller</li><li>指示服务端 Tiller 做事，比如根据 chart 创建一个 Release</li></ul></li><li>helm 服务端 <strong><code>tiller</code></strong><br>安装在 Kubernetes 集群内的一个应用， 用来执行客户端发来的命令，管理 Release</li></ol><h3 id="Helm的安装"><a href="#Helm的安装" class="headerlink" title="Helm的安装"></a>Helm的安装</h3><h4 id="Helm-Client-安装"><a href="#Helm-Client-安装" class="headerlink" title="Helm Client 安装"></a><code>Helm Client</code> 安装</h4><p>下载 helm 的相关版本: <a href="https://github.com/kubernetes/helm/releases">https://github.com/kubernetes/helm/releases</a></p><p>安装过程如下：</p><ol><li>下载 Helm </li><li>解包：tar -zxvf helm-v2.11.0-linux-amd64.tgz</li><li>helm 二进制文件移到 / usr/local/bin 目录</li></ol><h4 id="Helm-Tiller-安装"><a href="#Helm-Tiller-安装" class="headerlink" title="Helm Tiller  安装"></a><code>Helm Tiller </code> 安装</h4><blockquote><p>因为 Kubernetes APIServer 开启了 RBAC 访问控制，所以需要创建 tiller 使用的 service account: tiller 并分配合适的角色给它。这里简单起见直接分配 cluster-admin 这个集群内置的 ClusterRole 给它。创建 rbac-config.yaml 文件：</p></blockquote><pre><code class="hljs yaml"><span class="hljs-comment"># rbac-config.yaml</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">tiller</span>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1beta1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">tiller</span><span class="hljs-attr">roleRef:</span>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">cluster-admin</span><span class="hljs-attr">subjects:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">tiller</span>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span></code></pre><p>接下来使用 helm 部署 tiller:</p><pre><code class="hljs bash">helm init --service-account tiller --skip-refresh</code></pre><p>如果直接执行部署语句，要链接 <a href="https://kubernetes-charts.storage.googleapis.com/">https://kubernetes-charts.storage.googleapis.com</a> 去下载镜像；在国内这个地址不能直接访问，所以需要下载其他镜像；docker pull fengzos/tiller:v2.11.0 这个镜像是直接从 gcr.io/kubernetes-helm/tiller:v2.11.0 继承过来的，可以直接使用。</p><pre><code class="hljs bash">docker pull fengzos/tillerhelm init --service-account tiller --upgrade -i fengzos/tiller:latest  --skip-refresh</code></pre><h4 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h4><ol><li><code>helm help</code> 查看 helm 支持的命令</li><li><code>helm somecommand -h</code> 查看某个命令的使用方法</li><li><code>helm version</code> 查看客户端和服务端的版本，如果只显示了客户端版本，说明没有连上服务端。 它会自动去 K8s 上 kube-system 命名空间下查找是否有 Tiller 的 Pod 在运行，除非你通过 <code>--tiller-namespace</code>标签 or <code>TILLER_NAMESPACE</code>环境变量指定</li></ol><h3 id="Helm的使用"><a href="#Helm的使用" class="headerlink" title="Helm的使用"></a>Helm的使用</h3><h4 id="使用-Chart"><a href="#使用-Chart" class="headerlink" title="使用 Chart"></a>使用 Chart</h4><ul><li><code>helm search</code> 查找可用的 Charts</li><li><code>helm inspect</code> 查看指定 Chart 的基本信息</li><li><code>helm install</code> 根据指定的 Chart 部署一个 Release 到 K8s</li><li><code>helm create</code> 创建自己的 Chart</li><li><code>helm package</code> 打包 Chart，一般是一个压缩包文件</li></ul><h4 id="管理-Release"><a href="#管理-Release" class="headerlink" title="管理 Release"></a>管理 Release</h4><ul><li><code>helm list</code> 列出已经部署的 Release</li><li><code>helm delete [RELEASE]</code> 删除一个 Release. 并没有物理删除， 出于审计需要，历史可查</li><li><code>helm delete --purge [RELEASE]</code> 移除所有与指定 Release 相关的 K8s资源和所有这个 Release 的记录</li><li><code>helm status [RELEASE]</code> 查看指定的 Release 信息，即使使用<code>helm delete</code>命令删除的 Release.</li><li><code>helm upgrade</code> 升级某个 Release</li><li><code>helm rollback [RELEASE] [REVISION]</code> 回滚 Release 到指定发布序列</li><li><code>helm get values [RELEASE]</code> 查看 Release 的配置文件值</li></ul><h4 id="管理-Chart-Repository"><a href="#管理-Chart-Repository" class="headerlink" title="管理 Chart Repository"></a>管理 Chart Repository</h4><ul><li><code>helm repo list</code></li><li><code>helm repo add [RepoName] [RepoUrl]</code></li><li><code>helm repo update</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;先区分下概念&quot;&gt;&lt;a href=&quot;#先区分下概念&quot; class=&quot;headerlink&quot; title=&quot;先区分下概念&quot;&gt;&lt;/a&gt;先区分下概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Docker&lt;/code&gt;&lt;/strong&gt;: 镜像是把一个单纯的 </summary>
      
    
    
    
    <category term="技术加油站" scheme="https://liei.cc/blog/categories/%E6%8A%80%E6%9C%AF%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    
    
    <category term="Cloud Navite" scheme="https://liei.cc/blog/tags/cloud-navite/"/>
    
    <category term="Kubernetes" scheme="https://liei.cc/blog/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>vscode + sftp 开发环境同步差异文件</title>
    <link href="https://liei.cc/2018/sftp-sync-project.html"/>
    <id>https://liei.cc/2018/sftp-sync-project.html</id>
    <published>2018-09-15T06:15:15.000Z</published>
    <updated>2018-09-15T06:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="tag-plugin note" ><div class="title"><strong>radiation,</strong></div><div class="body"><p>解决需求： 本地是 win10 系统，代码需要在 linux 下跑，又不想装虚拟机或双系统； 所以，项目用到连接远程测试服务器进行开发联调，需要安装 SFTP/FTP 的扩展插件才能同步代码； 还有其他实现方法，如，Git 工作流、winscp、rzlz 等，但大都不太灵活，甚至麻烦</p></div></div><h2 id="CentOS-7-配置使用-SFTP-服务器"><a href="#CentOS-7-配置使用-SFTP-服务器" class="headerlink" title="CentOS 7 配置使用 SFTP 服务器"></a>CentOS 7 配置使用 SFTP 服务器</h2><h3 id="何为-SFTP？"><a href="#何为-SFTP？" class="headerlink" title="何为 SFTP？"></a>何为 SFTP？</h3><p>SFTP，即 SSH 文件传输协议（ SSH File Transfer Protocol ），或者说是安全文件传输协议（ Secure File Transfer Protocol ）。SFTP 是一个独立的 SSH 封装协议包，通过安全连接以相似的方式工作。它的优势在于可以利用安全的连接传输文件，还能浏览本地和远程系统上的文件系统。</p><p>在很多情况下，SFTP 都比 FTP 更可取，因为它具有最基本的安全特性和能利用 SSH 连接的能力，FTP 是一种不安全的协议，只能在有限的情况下或在您信任的网络上使用。</p><p><strong>先决条件：</strong></p><p>服务器 <code>OpenSSH-Server</code> 版本最低 4.8p1，因为配置权限需要版本添加的新配置项 <code>ChrootDirectory</code> 来完成。</p><p>如何查看 OpenSSH 版本，命令如下：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ssh -V</span>OpenSSH_7.4p1, OpenSSL 1.0.2k-fips  26 Jan 2017</code></pre><h3 id="创建用户信息"><a href="#创建用户信息" class="headerlink" title="创建用户信息"></a>创建用户信息</h3><p>添加用户组：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> groupadd sftp</span></code></pre><p>添加用户：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> useradd -g sftp -s /sbin/nologin -M leeifme</span></code></pre><p>参数注解：</p><pre><code class="hljs shell">-g              # 加入用户组-s              # 指定用户登入后所使用的shell/sbin/nologin   # 用户不允许登录-M              # 不要自动建立用户的登入目录</code></pre><p>设置用户密码：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> passwd leeifme</span></code></pre><h3 id="创建用户目录并设置权限"><a href="#创建用户目录并设置权限" class="headerlink" title="创建用户目录并设置权限"></a>创建用户目录并设置权限</h3><p>创建 sftp 主目录：</p><pre><code class="hljs sh">$ mkdir /home/danaos</code></pre><p>设置 sftp 主目录权限：</p><pre><code class="hljs sh">$ chown root:sftp /home/danaos</code></pre><p>文件夹所有者必须是 root，用户组可以不是 root</p><pre><code class="hljs sh">$ chmod 755 /home/danaos</code></pre><p>权限不能超过 755 但不包括 755，否则会导致登录报错</p><h3 id="创建上传目录并设置权限"><a href="#创建上传目录并设置权限" class="headerlink" title="创建上传目录并设置权限"></a>创建上传目录并设置权限</h3><p>在<code>/home/danaos/</code>主目录下创建<code>archer</code>项目文件夹，并设置所有者是：<code>leeifme</code>，用户组隶属：<code>sftp</code>，这样新增的帐号才能有上传编辑的权限。</p><pre><code class="hljs sh">$ mkdir -p /home/danaos/archer$ chown leeifme:sftp /home/danaos/archer</code></pre><h3 id="修改-sshd-config-配置文件"><a href="#修改-sshd-config-配置文件" class="headerlink" title="修改 sshd_config 配置文件"></a>修改 sshd_config 配置文件</h3><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> vim /etc/ssh/sshd_config</span></code></pre><p>将此行注释掉，例如：</p><pre><code class="hljs sh"><span class="hljs-comment">#Subsystem sftp /usr/libexec/openssh/sftp-server</span></code></pre><p>在此行下面添加如下内容：</p><pre><code class="hljs sh">Subsystem sftp internal-sftp       <span class="hljs-comment"># 指定使用sftp服务使用系统自带的internal-sftp</span>Match Group sftp                   <span class="hljs-comment"># 匹配sftp组的用户,若要匹配多个组,可用逗号分开</span>ChrootDirectory /home/danaos       <span class="hljs-comment"># 限制用户的根目录</span>ForceCommand internal-sftp         <span class="hljs-comment"># 只能用于sftp登录</span>AllowTcpForwarding no              <span class="hljs-comment"># 禁止用户使用端口转发</span>X11Forwarding no                   <span class="hljs-comment"># 禁止用户使用端口转发</span></code></pre><h3 id="重启-SSH-服务"><a href="#重启-SSH-服务" class="headerlink" title="重启 SSH 服务"></a>重启 SSH 服务</h3><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> systemctl restart sshd</span></code></pre><h3 id="测试是否能够登录、上传、下载等操作"><a href="#测试是否能够登录、上传、下载等操作" class="headerlink" title="测试是否能够登录、上传、下载等操作"></a>测试是否能够登录、上传、下载等操作</h3><p>在<code>10.28.204.61</code>服务器执行以下命令登录：</p><pre><code class="hljs sh">$ sftp leeifme@192.168.50.124leeifme@192.168.50.124<span class="hljs-string">&#x27;s password:</span><span class="hljs-string">Connected to leeifme@192.168.50.124.</span><span class="hljs-string">sftp&gt; ls</span><span class="hljs-string">archer</span><span class="hljs-string">sftp&gt; cd archer/</span><span class="hljs-string">sftp&gt;</span></code></pre><p><strong>上传</strong></p><pre><code class="hljs sh">sftp&gt; put test.goUploading test.go to /archer/test.gotest.go             100% 3824   626.2KB/s   00:00sftp&gt;</code></pre><p><strong>下载</strong></p><pre><code class="hljs sh">sftp&gt; get test.goFetching /archer/test.go to test.go/archer/oplog.go    100% 3824   475.1KB/s   00:00sftp&gt;</code></pre><p><strong>删除</strong></p><pre><code class="hljs sh">sftp&gt; rm test.goRemoving test.go</code></pre><p><strong>更多命令请参阅</strong></p><pre><code class="hljs shell"><span class="hljs-meta">sftp&gt;</span><span class="bash"> <span class="hljs-built_in">help</span></span></code></pre><h2 id="vscode-配置-sftp"><a href="#vscode-配置-sftp" class="headerlink" title="vscode 配置 sftp"></a>vscode 配置 sftp</h2><h3 id="下载-sftp-插件"><a href="#下载-sftp-插件" class="headerlink" title="下载 sftp 插件"></a>下载 sftp 插件</h3><ul><li>在 vscode 中快捷键 <code>ctrl+shift+P</code> 打开指令窗口，输入<code>extension:install</code>，回车，左侧即打开扩展安装的界面 </li><li>在搜索框中输入<code>sftp</code>，第一个就是需要安装的，点安装(可以参考下载数，选择适合自己的插件，功能大都大同小异)</li></ul><h3 id="在-vscode-的工程中配置-sftp-json"><a href="#在-vscode-的工程中配置-sftp-json" class="headerlink" title="在 vscode 的工程中配置 sftp.json"></a>在 vscode 的工程中配置 sftp.json</h3><p>然后快捷键 <code>ctrl+shift+P</code> 打开指令窗口，输入<code>sftp:config</code>，回车，就会在当前工作工程的<code>.vscode</code>文件夹下生成一个<code>sftp.json</code>文件，不知道哪天似乎是插件更新了，默认的文件非常空，我们只能手动配置文件的参数了。配置好<code>host, port, username, privateKeyPath, remotePath, ignore</code>这参数即可：</p><ul><li>host：工作站的 IP 地址</li><li>port：ssh 的端口</li><li>username：工作站自己的用户名</li><li>privateKeyPath：存放在本地的已配置好的用于登录工作站的密钥文件。和下面的使用密码二选一（可以是 openssh 格式的，也可以是 ppk 格式的）</li><li>password：工作站自己的用户密码。使用密钥和使用密码选用一种即可；使用密码的话工作站不用配置 ssh，但使用密钥的话工作站上需要配置好 ssh，password 就可以填 null</li><li>protocol：协议类型，默认选<code>&quot;sftp&quot;</code></li><li>remotePath：工作站上与本地工程同步的文件夹路径，需要和本地工程文件根目录同名，且在使用 sftp 上传文件之前要手动在工作站上使用mkdir生成这个根目录，根目录下的其他子目录会自动对应生成</li><li>ignore：指定在使用<code>sftp: sync to remote</code>的时候忽略的文件及文件夹，注意每一行后面有逗号，最后一行没有逗号</li><li>debug： 默认是 false，如果设置为 true，可以看到通过菜单的 查看 -&gt; 输出 打开输出界面，看到打印，怀疑自己连接有问题的可以打开看看</li><li>uploadOnSave: 默认是 false，建议设置成 true，这样每次修改后 ctrl+s 保存后会自动同步。否则就需要手动同步</li></ul><p>举个栗子：（<strong>记住不能有任何注释内容</strong>）</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;sftp&quot;</span>,    <span class="hljs-attr">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.50.124&quot;</span>,    <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">22</span>,    <span class="hljs-attr">&quot;username&quot;</span>: <span class="hljs-string">&quot;leeifme&quot;</span>,    <span class="hljs-attr">&quot;password&quot;</span>: <span class="hljs-string">&quot;XXXXXXXXXX&quot;</span>,    <span class="hljs-attr">&quot;remotePath&quot;</span>: <span class="hljs-string">&quot;archer/&quot;</span>,    <span class="hljs-attr">&quot;watcher&quot;</span>: &#123;        <span class="hljs-attr">&quot;files&quot;</span>: <span class="hljs-string">&quot;**/&quot;</span>,         <span class="hljs-attr">&quot;autoUpload&quot;</span>: <span class="hljs-literal">true</span>,         <span class="hljs-attr">&quot;autoDelete&quot;</span>: <span class="hljs-literal">true</span>     &#125;,    <span class="hljs-attr">&quot;ignore&quot;</span>: [        <span class="hljs-string">&quot;**/.git/**&quot;</span>    ]&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;div class=&quot;tag-plugin note&quot; &gt;&lt;div class=&quot;title&quot;&gt;&lt;strong&gt;radiation,&lt;/stro</summary>
      
    
    
    
    <category term="折腾不止" scheme="https://liei.cc/blog/categories/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2/"/>
    
    
    <category term="VSCode" scheme="https://liei.cc/blog/tags/vscode/"/>
    
    <category term="Linux" scheme="https://liei.cc/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>暴力学习 k8s - 集群搭建</title>
    <link href="https://liei.cc/2018/k8s-cluster-deploy.html"/>
    <id>https://liei.cc/2018/k8s-cluster-deploy.html</id>
    <published>2018-09-01T06:15:15.000Z</published>
    <updated>2018-09-01T06:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>其实，搭建一个 Kubernetes（K8S）集群不是一件容易的事情，主要困难有两个：</p><ul><li>那一道厚厚的墙</li><li>对 K8S 的知识不熟悉</li></ul><p>只要能解决上面两个问题，搭建的过程实际上就没有那么复杂了。</p><p>本系列是我在搭建过程中踩的无数坑 、以及查阅众多相关问题解决的文章的一些记录和总结。</p></blockquote><h2 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h2><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><ul><li>节点网络： 192.168.31.0/24</li><li>service 网络： 10.96.0.0/12</li><li>pod 网络： 10.244.0.0/16</li></ul><h3 id="kubeadm-部署"><a href="#kubeadm-部署" class="headerlink" title="kubeadm 部署"></a>kubeadm 部署</h3><h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><ul><li>kubeadm 项目<a href="https://github.com/kubernetes/kubeadm">链接地址</a></li><li>master、node： 安装 <code>kubelet</code>、 <code>kubeadm</code>、 <code>docker</code></li><li>master： <code>kubeadm init</code></li><li>node： <code>kubeadm join</code></li><li><code>apiserver</code>、<code>scheduler</code>、<code>Controller-manager</code>、<code>etcd</code> 在 master 上以 Pod 运行</li><li><code>kubeproxy</code> 以 Pod 方式运行在每一个 node 节点上。</li><li>以上 pod 均为静态 Pod</li><li>每一个节点都需要运行 <code>flannel</code>（也是以 Pod 方式运行），以提供 Pod 网络</li><li>kubeadm 的<a href="https://github.com/kubernetes/kubeadm/blob/master/docs/design/design_v1.10.md">介绍</a></li></ul><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><ol><li>master，node 需要安装 kubelet， kubeadm， docker</li><li>master 节点上运行 <code>kubeadm init</code></li><li>node 节点上运行 <code>kubeadm join</code> 加入集群</li></ol><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><h3 id="我的环境"><a href="#我的环境" class="headerlink" title="我的环境"></a>我的环境</h3><pre><code class="hljs sh">[root@master yum.repos.d]<span class="hljs-comment"># cat /etc/redhat-release </span>CentOS Linux release 7.4.1708 (Core) [root@master yum.repos.d]<span class="hljs-comment"># uname -a</span>Linux master 3.10.0-693.el7.x86_64 <span class="hljs-comment">#1 SMP Tue Aug 22 21:09:27 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span></code></pre><h3 id="节点解析"><a href="#节点解析" class="headerlink" title="节点解析"></a>节点解析</h3><p>通过 <code>/etc/hosts</code> 文件解析</p><pre><code class="hljs sh">192.168.31.81 master.test.com master192.168.31.82 node01.test.com node01192.168.31.83 node02.test.com node02</code></pre><p><strong>集群通过时间服务器做时钟同步</strong>，我没做</p><h3 id="节点互信"><a href="#节点互信" class="headerlink" title="节点互信"></a>节点互信</h3><p>可以按照此<a href="https://www.cnblogs.com/jyzhao/p/3781072.html">文档</a>配置节点互信，也没有做</p><h3 id="选择版本"><a href="#选择版本" class="headerlink" title="选择版本"></a>选择版本</h3><p>使用 kubernetes v1.11.2</p><h2 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h2><p><strong>确保 iptables firewalld 等未启动, 且不开机自启动</strong>，可参考我之前的 CentOS 安装</p><h3 id="配置-yum-仓库"><a href="#配置-yum-仓库" class="headerlink" title="配置 yum 仓库"></a>配置 yum 仓库</h3><p>使用 aliyun 源，<a href="https://opsx.alibaba.com/mirror">链接</a></p><h4 id="docker-源使用如下命令获取"><a href="#docker-源使用如下命令获取" class="headerlink" title="docker 源使用如下命令获取"></a>docker 源使用如下命令获取</h4><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /etc/yum.repos.dwget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre><h4 id="kubernetes-源"><a href="#kubernetes-源" class="headerlink" title="kubernetes 源"></a>kubernetes 源</h4><pre><code class="hljs sh">[root@master yum.repos.d]<span class="hljs-comment"># cat kubernetes.repo </span>[kubernetes]name=Kubernetes Repobaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgenabled=1</code></pre><h4 id="查看源是否生效"><a href="#查看源是否生效" class="headerlink" title="查看源是否生效"></a>查看源是否生效</h4><pre><code class="hljs plain"># yum clean all# yum repolist**********Determining fastest mirrorskubernetes                                                         243&#x2F;243repo id                         repo name                            statusbase&#x2F;7&#x2F;x86_64                   CentOS-7 - Base - 163.com            9,911docker-ce-stable&#x2F;x86_64         Docker CE Stable - x86_64               16extras&#x2F;7&#x2F;x86_64                 CentOS-7 - Extras - 163.com            370kubernetes                      Kubernetes Repo                        243updates&#x2F;7&#x2F;x86_64                CentOS-7 - Updates - 163.com         1,054repolist: 11,594</code></pre><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p><strong>三台机器都需要安装</strong></p><p>使用 <code>yum install docker-ce kubelet kubeadm kubectl</code> 安装</p><p>安装的软件包如下：</p><pre><code class="hljs plain">Installing : kubectl-1.11.2-0.x86_64                                 1&#x2F;7 Installing : cri-tools-1.11.0-0.x86_64                               2&#x2F;7 Installing : socat-1.7.3.2-2.el7.x86_64                              3&#x2F;7 Installing : kubernetes-cni-0.6.0-0.x86_64                           4&#x2F;7 Installing : kubelet-1.11.2-0.x86_64                                 5&#x2F;7 Installing : kubeadm-1.11.2-0.x86_64                                 6&#x2F;7 Installing : docker-ce-18.06.0.ce-3.el7.x86_64                       7&#x2F;7</code></pre><h3 id="启动-docker-服务等"><a href="#启动-docker-服务等" class="headerlink" title="启动 docker 服务等"></a>启动 docker 服务等</h3><p>由于国内网络原因，kubernetes 的镜像托管在 google 云上，无法直接下载，需要设置 proxy<br>在 <code>/usr/lib/systemd/system/docker.service</code> 文件中添加如下两行</p><pre><code class="hljs shell">[root@master ~]# cat /usr/lib/systemd/system/docker.service |grep PROXYEnvironment=&quot;HTTPS_PROXY=http://www.ik8s.io:10080&quot;Environment=&quot;NO_PROXY=127.0.0.0/8,192.168.31.0/24&quot;</code></pre><p>之后，启动 docker</p><pre><code class="hljs shell">systemctl daemon-reloadsystemctl start dockersystemctl enable docker</code></pre><p>确认 proc 的这两个参数如下，均为 1</p><pre><code class="hljs shell">[root@master ~]# cat /proc/sys/net/bridge/bridge-nf-call-iptables 1[root@master ~]# cat /proc/sys/net/bridge/bridge-nf-call-ip6tables 1解决方法：修改系统文件是的机器 bridge 模式开启设置机器开机启动的时候执行下面两条命令编辑 vim  /etc/rc.d/rc.local 添加下面两条命令        echo 1 &gt; /proc/sys/net/bridge/bridge-nf-call-iptables        echo 1 &gt; /proc/sys/net/bridge/bridge-nf-call-ip6tablescentos7 需要增加执行权限：        chmod +x　/etc/rc,d/rc.local重启系统</code></pre><h3 id="设置-kubelet"><a href="#设置-kubelet" class="headerlink" title="设置 kubelet"></a>设置 kubelet</h3><p>查看 kubelet 安装生成了哪些文件</p><pre><code class="hljs shell">[root@master ~]# rpm -ql kubelet/etc/kubernetes/manifests              # 清单目录/etc/sysconfig/kubelet                 # 配置文件/etc/systemd/system/kubelet.service    # unit file/usr/bin/kubelet                       # 主程序</code></pre><p><strong>默认</strong>的配置文件</p><pre><code class="hljs shell">[root@master ~]# cat /etc/sysconfig/kubeletKUBELET_EXTRA_ARGS=</code></pre><p>修改 kubelet 的配置文件</p><pre><code class="hljs shell">[root@master ~]# cat /etc/sysconfig/kubeletKUBELET_EXTRA_ARGS=&quot;--fail-swap-on=false&quot;</code></pre><p>此时还无法正常启动 kubelet，先设置 kubelet 开机自启动，使用如下命令： <code>systemctl enable kubelet</code> 。</p><h3 id="kubeadm-init"><a href="#kubeadm-init" class="headerlink" title="kubeadm init"></a>kubeadm init</h3><p>在 master 节点上执行</p><pre><code class="hljs shell">kubeadm init --kubernetes-version=v1.11.2 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12 --ignore-preflight-errors=Swap</code></pre><p>kubeadm init 的输出可见于此<a href="https://segmentfault.com/n/1330000016057102">链接</a></p><p>此命令，下载了如下 image</p><pre><code class="hljs shell">[root@master ~]# docker imagesREPOSITORY                                 TAG                 IMAGE ID            CREATED             SIZEk8s.gcr.io/kube-proxy-amd64                v1.11.2             46a3cd725628        7 days ago          97.8MBk8s.gcr.io/kube-apiserver-amd64            v1.11.2             821507941e9c        7 days ago          187MBk8s.gcr.io/kube-controller-manager-amd64   v1.11.2             38521457c799        7 days ago          155MBk8s.gcr.io/kube-scheduler-amd64            v1.11.2             37a1403e6c1a        7 days ago          56.8MBk8s.gcr.io/coredns                         1.1.3               b3b94275d97c        2 months ago        45.6MBk8s.gcr.io/etcd-amd64                      3.2.18              b8df3b177be2        4 months ago        219MBk8s.gcr.io/pause                           3.1                 da86e6ba6ca1        7 months ago        742kB</code></pre><p>现在，正在运行的 docker 如下</p><pre><code class="hljs sh">[root@master ~]<span class="hljs-comment"># docker ps</span>CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS               NAMES1c03e043e6b7        46a3cd725628           <span class="hljs-string">&quot;/usr/local/bin/kube??   3 minutes ago       Up 3 minutes                            k8s_kube-proxy_kube-proxy-6fgjm_kube-system_f85e8660-a090-11e8-8ee7-000c29f71e04_0</span><span class="hljs-string">5f166bd11566        k8s.gcr.io/pause:3.1   &quot;</span>/pause<span class="hljs-string">&quot;                 3 minutes ago       Up 3 minutes                            k8s_POD_kube-proxy-6fgjm_kube-system_f85e8660-a090-11e8-8ee7-000c29f71e04_0</span><span class="hljs-string">0f306f98cc52        b8df3b177be2           &quot;</span>etcd --advertise-cl??   3 minutes ago       Up 3 minutes                            k8s_etcd_etcd-master_kube-system_2cc1c8a24b68ab9b46bca47e153e74c6_08f01317b9e20        37a1403e6c1a           <span class="hljs-string">&quot;kube-scheduler --ad??   3 minutes ago       Up 3 minutes                            k8s_kube-scheduler_kube-scheduler-master_kube-system_a00c35e56ebd0bdfcd77d53674a5d2a1_0</span><span class="hljs-string">4e6a71ab20d3        821507941e9c           &quot;</span>kube-apiserver --au??   3 minutes ago       Up 3 minutes                            k8s_kube-apiserver_kube-apiserver-master_kube-system_d25d40ebb427821464356bb27a38f487_069e4c5dae335        38521457c799           <span class="hljs-string">&quot;kube-controller-man??   3 minutes ago       Up 3 minutes                            k8s_kube-controller-manager_kube-controller-manager-master_kube-system_6363f7ebf727b0b95d9a9ef72516a0e5_0</span><span class="hljs-string">da5981dc546a        k8s.gcr.io/pause:3.1   &quot;</span>/pause<span class="hljs-string">&quot;                 3 minutes ago       Up 3 minutes                            k8s_POD_kube-controller-manager-master_kube-system_6363f7ebf727b0b95d9a9ef72516a0e5_0</span><span class="hljs-string">b7a8fdc35029        k8s.gcr.io/pause:3.1   &quot;</span>/pause<span class="hljs-string">&quot;                 3 minutes ago       Up 3 minutes                            k8s_POD_kube-apiserver-master_kube-system_d25d40ebb427821464356bb27a38f487_0</span><span class="hljs-string">b09efc7ff7bd        k8s.gcr.io/pause:3.1   &quot;</span>/pause<span class="hljs-string">&quot;                 3 minutes ago       Up 3 minutes                            k8s_POD_kube-scheduler-master_kube-system_a00c35e56ebd0bdfcd77d53674a5d2a1_0</span><span class="hljs-string">ab11d6ffadab        k8s.gcr.io/pause:3.1   &quot;</span>/pause<span class="hljs-string">&quot;                 3 minutes ago       Up 3 minutes                            k8s_POD_etcd-master_kube-system_2cc1c8a24b68ab9b46bca47e153e74c6_0</span></code></pre><p>node 节点可以通过如下命令加入集群 <code>kubeadm join 192.168.31.81:6443 --token n84v6t.c7d83cn4mo2z8wyr --discovery-token-ca-cert-hash sha256:b946c145416fe1995e1d4d002c149e71a897acc7b106d94cee2920cb2c85ce29</code> </p><p>在 kubeadm init 的<a href="https://segmentfault.com/a/1190000016026998">输出</a>中，提示我们需要以普通用户做如下操作，我此时用 root 执行</p><pre><code class="hljs sh">[root@master ~]<span class="hljs-comment"># mkdir -p $HOME/.kube</span>[root@master ~]<span class="hljs-comment"># cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span></code></pre><p>此时可以通过 <code>kubelet get</code> 获取各种资源信息。比如</p><pre><code class="hljs sh">[root@master ~]<span class="hljs-comment"># kubectl get cs</span>NAME                 STATUS    MESSAGE              ERRORscheduler            Healthy   ok                   controller-manager   Healthy   ok                   etcd-0               Healthy   &#123;<span class="hljs-string">&quot;health&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>&#125;</code></pre><p>此时的监听状态</p><pre><code class="hljs sh">[root@master ~]<span class="hljs-comment"># ss -tnl</span>State       Recv-Q Send-Q Local Address:Port               Peer Address:Port              LISTEN      0      128    127.0.0.1:2379                  *:*                  LISTEN      0      128    127.0.0.1:10251                 *:*                  LISTEN      0      128    127.0.0.1:2380                  *:*                  LISTEN      0      128    127.0.0.1:10252                 *:*                  LISTEN      0      128       *:22                    *:*                  LISTEN      0      128    127.0.0.1:33881                 *:*                  LISTEN      0      100    127.0.0.1:25                    *:*                  LISTEN      0      128    192.168.18.128:10010                 *:*                  LISTEN      0      128    127.0.0.1:10248                 *:*                  LISTEN      0      128    127.0.0.1:10249                 *:*                  LISTEN      0      128      :::6443                 :::*                  LISTEN      0      128      :::10256                :::*                  LISTEN      0      128      :::22                   :::*                  LISTEN      0      100     ::1:25                   :::*                  LISTEN      0      128      :::10250                :::*</code></pre><p>此时的节点状态</p><pre><code class="hljs sh">[root@master ~]<span class="hljs-comment"># kubectl get nodes</span>NAME      STATUS     ROLES     AGE       VERSIONmaster    NotReady   master    9m        v1.11.2</code></pre><p>状态为 <code>NotReady</code> ， 需要部署 flannel，<a href="https://github.com/coreos/flannel">链接</a></p><h3 id="部署-flannel"><a href="#部署-flannel" class="headerlink" title="部署 flannel"></a>部署 flannel</h3><p>在文档中，找到如下命令，部署</p><pre><code class="hljs sh">[root@master ~]<span class="hljs-comment"># kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span>clusterrole.rbac.authorization.k8s.io/flannel createdclusterrolebinding.rbac.authorization.k8s.io/flannel createdserviceaccount/flannel createdconfigmap/kube-flannel-cfg createddaemonset.extensions/kube-flannel-ds-amd64 createddaemonset.extensions/kube-flannel-ds-arm64 createddaemonset.extensions/kube-flannel-ds-arm createddaemonset.extensions/kube-flannel-ds-ppc64le createddaemonset.extensions/kube-flannel-ds-s390x created</code></pre><p>按如下方法查看：</p><pre><code class="hljs sh">[root@master ~]<span class="hljs-comment"># kubectl get pods -n  kube-system</span>NAME                             READY     STATUS    RESTARTS   AGEcoredns-78fcdf6894-cv4gp         1/1       Running   0          13mcoredns-78fcdf6894-wmd25         1/1       Running   0          13metcd-master                      1/1       Running   0          49skube-apiserver-master            1/1       Running   0          49skube-controller-manager-master   1/1       Running   0          48skube-flannel-ds-amd64-r42wr      1/1       Running   0          2mkube-proxy-6fgjm                 1/1       Running   0          13mkube-scheduler-master            1/1       Running   0          48s[root@master ~]<span class="hljs-comment"># docker images |grep flannel</span>quay.io/coreos/flannel                     v0.10.0-amd64       f0fad859c909        6 months ago        44.6MB[root@master ~]<span class="hljs-comment"># kubectl get nodes</span>NAME      STATUS    ROLES     AGE       VERSIONmaster    Ready     master    14m       v1.11.2</code></pre><p>此时 master 节点状态变为 <code>Ready</code> 。</p><h3 id="在-node-节点上执行-kubeadm-join-命令"><a href="#在-node-节点上执行-kubeadm-join-命令" class="headerlink" title="在 node 节点上执行 kubeadm join 命令"></a>在 node 节点上执行 <code>kubeadm join</code> 命令</h3><p>使用 master 节点执行 <code>kubeadm init</code> 命令的输出，在 node 上执行，使其加入集群。</p><pre><code class="hljs sh">[root@node01 ~]<span class="hljs-comment">#   kubeadm join 192.168.18.128:6443 --token n84v6t.c7d83cn4mo2z8wyr --discovery-token-ca-cert-hash sha256:b946c145416fe1995e1d4d002c149e71a897acc7b106d94cee2920cb2c85ce29 --ignore-preflight-errors=Swap</span>[preflight] running pre-flight checks    [WARNING RequiredIPVSKernelModulesAvailable]: the IPVS proxier will not be used, because the following required kernel modules are not loaded: [ip_vs ip_vs_rr ip_vs_wrr ip_vs_sh] or no <span class="hljs-built_in">builtin</span> kernel ipvs support: map[ip_vs_sh:&#123;&#125; nf_conntrack_ipv4:&#123;&#125; ip_vs:&#123;&#125; ip_vs_rr:&#123;&#125; ip_vs_wrr:&#123;&#125;]you can solve this problem with following methods: 1. Run <span class="hljs-string">&#x27;modprobe -- &#x27;</span> to load missing kernel modules;2. Provide the missing <span class="hljs-built_in">builtin</span> kernel ipvs support    [WARNING Swap]: running with swap on is not supported. Please <span class="hljs-built_in">disable</span> swapI0815 22:02:30.751069   15460 kernel_validator.go:81] Validating kernel versionI0815 22:02:30.751145   15460 kernel_validator.go:96] Validating kernel config    [WARNING SystemVerification]: docker version is greater than the most recently validated version. Docker version: 18.06.0-ce. Max validated version: 17.03[discovery] Trying to connect to API Server <span class="hljs-string">&quot;192.168.18.128:6443&quot;</span>[discovery] Created cluster-info discovery client, requesting info from <span class="hljs-string">&quot;https://192.168.18.128:6443&quot;</span>[discovery] Requesting info from <span class="hljs-string">&quot;https://192.168.18.128:6443&quot;</span> again to validate TLS against the pinned public key[discovery] Cluster info signature and contents are valid and TLS certificate validates against pinned roots, will use API Server <span class="hljs-string">&quot;192.168.18.128:6443&quot;</span>[discovery] Successfully established connection with API Server <span class="hljs-string">&quot;192.168.18.128:6443&quot;</span>[kubelet] Downloading configuration <span class="hljs-keyword">for</span> the kubelet from the <span class="hljs-string">&quot;kubelet-config-1.11&quot;</span> ConfigMap <span class="hljs-keyword">in</span> the kube-system namespace[kubelet] Writing kubelet configuration to file <span class="hljs-string">&quot;/var/lib/kubelet/config.yaml&quot;</span>[kubelet] Writing kubelet environment file with flags to file <span class="hljs-string">&quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span>[preflight] Activating the kubelet service[tlsbootstrap] Waiting <span class="hljs-keyword">for</span> the kubelet to perform the TLS Bootstrap...[patchnode] Uploading the CRI Socket information <span class="hljs-string">&quot;/var/run/dockershim.sock&quot;</span> to the Node API object <span class="hljs-string">&quot;node01&quot;</span> as an annotationThis node has joined the cluster:* Certificate signing request was sent to master and a response  was received.* The Kubelet was informed of the new secure connection details.Run <span class="hljs-string">&#x27;kubectl get nodes&#x27;</span> on the master to see this node join the cluster.</code></pre><p>在两个节点上，执行完毕上述命令后，在 master 上查看</p><pre><code class="hljs sh">[root@master ~]<span class="hljs-comment"># kubectl get nodes</span>NAME      STATUS    ROLES     AGE       VERSIONmaster    Ready     master    23m       v1.11.2node01    Ready     &lt;none&gt;    2m        v1.11.2node02    Ready     &lt;none&gt;    1m        v1.11.2</code></pre><p>部署成功。</p><h2 id="部署完成后的观察"><a href="#部署完成后的观察" class="headerlink" title="部署完成后的观察"></a>部署完成后的观察</h2><p><strong>检查现在正在运行的 pod</strong></p><pre><code class="hljs sh">[root@master ~]<span class="hljs-comment"># kubectl get pods -n kube-system -o wide</span>NAME                             READY     STATUS    RESTARTS   AGE       IP               NODE      NOMINATED NODEcoredns-78fcdf6894-cv4gp         1/1       Running   0          28m       10.244.0.3       master    &lt;none&gt;coredns-78fcdf6894-wmd25         1/1       Running   0          28m       10.244.0.2       master    &lt;none&gt;etcd-master                      1/1       Running   0          15m       192.168.18.128   master    &lt;none&gt;kube-apiserver-master            1/1       Running   0          15m       192.168.18.128   master    &lt;none&gt;kube-controller-manager-master   1/1       Running   0          15m       192.168.18.128   master    &lt;none&gt;kube-flannel-ds-amd64-48rvq      1/1       Running   3          6m        192.168.18.130   node02    &lt;none&gt;kube-flannel-ds-amd64-7dw42      1/1       Running   3          7m        192.168.18.129   node01    &lt;none&gt;kube-flannel-ds-amd64-r42wr      1/1       Running   0          16m       192.168.18.128   master    &lt;none&gt;kube-proxy-6fgjm                 1/1       Running   0          28m       192.168.18.128   master    &lt;none&gt;kube-proxy-6mngv                 1/1       Running   0          7m        192.168.18.129   node01    &lt;none&gt;kube-proxy-9sh2n                 1/1       Running   0          6m        192.168.18.130   node02    &lt;none&gt;kube-scheduler-master            1/1       Running   0          15m       192.168.18.128   master    &lt;none&gt;</code></pre><p>可以发现：</p><ol><li>kube-apiserver， kube-scheduler， kube-controller，etcd-master 运行在 master 上，</li><li>kube-flannel 在三个节点上均有运行</li><li>kube-proxy 在三个节点均有运行</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;其实，搭建一个 Kubernetes（K8S）集群不是一件容易的事情，主要困难有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="折腾不止" scheme="https://liei.cc/blog/categories/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2/"/>
    
    
    <category term="Cloud Navite" scheme="https://liei.cc/blog/tags/cloud-navite/"/>
    
    <category term="Kubernetes" scheme="https://liei.cc/blog/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>开启云原生之门</title>
    <link href="https://liei.cc/2018/open-cloud-native-study.html"/>
    <id>https://liei.cc/2018/open-cloud-native-study.html</id>
    <published>2018-08-25T06:15:15.000Z</published>
    <updated>2018-08-25T06:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是云原生"><a href="#什么是云原生" class="headerlink" title="什么是云原生"></a>什么是云原生</h2><h3 id="CNCF组织"><a href="#CNCF组织" class="headerlink" title="CNCF组织"></a>CNCF组织</h3><p>在讲云原生之前，我们先了解一下 CNCF ，即云原生计算基金会，2015年由谷歌牵头成立，基金会成员目前已有一百多企业与机构，包括亚马逊、微软。思科等巨头。目前 CNCF 所托管的应用已达14个，下图为其公布的Cloud Native Landscape，给出了云原生生态的参考体系：</p><img src = "https://leeifme-1252179361.cos.ap-shanghai.myqcloud.com/blog/CNCF.png"><h3 id="云原生-Cloud-Native"><a href="#云原生-Cloud-Native" class="headerlink" title="云原生(Cloud Native)"></a>云原生(Cloud Native)</h3><p>CNCF 给出了云原生应用的三大特征：</p><ul><li>容器化封装：以容器为基础，提高整体开发水平，形成代码和组件重用，简化云原生应用程序的维护。在容器中运行应用程序和进程，并作为应用程序部署的独立单元，实现高水平资源隔离。</li><li>动态管理：通过集中式的编排调度系统来动态的管理和调度。</li><li>面向微服务：明确服务间的依赖，互相解耦。</li></ul><p>云原生包含了一组应用的模式，用于帮助企业快速，持续，可靠，规模化地交付业务软件。云原生由微服务架构，DevOps 和以容器为代表的敏捷基础架构组成。这边引用网上关于云原生所需要的能力和特征总结：</p><img src = "https://leeifme-1252179361.cos.ap-shanghai.myqcloud.com/blog/yunyuansheng.jpg"><h3 id="应用部署运行模式的变迁"><a href="#应用部署运行模式的变迁" class="headerlink" title="应用部署运行模式的变迁"></a>应用部署运行模式的变迁</h3><blockquote><p>学习一个新事物之前呢，我们应该先了解    该事物发展的历程和规律，<code>Kubernetes</code> 的出现就是应用部署运行模式在外部条件需求变更的情况下，演化出来的结果</p></blockquote><p><strong>物理机模式</strong>(物理机-操作系统-应用)</p><p><strong>虚拟化模式</strong>(虚拟机-应用)</p><p><strong>容器化模式</strong></p><ul><li>以 Docker为代表的内核容器技术不是新技术,而是将已有技术(LXC、 groups、 Union fs)进行了更好的整合和包装,并形成了<br>一种标准镜像格式</li><li>与VM相比,容器具有开发交付流程操作对象同步、执行更为高效资源占用更为集约等优势。</li><li>计算基本单元由虚拟机变为了容器,越来越多应用的构建、部署与运行选择在容器中进行。</li></ul><p><strong>云原生模式</strong></p><ul><li>随着容器技术的岀现以及应用所面临的外部环境的变化,云原生逐渐成为一种应用云化开发、部署和运行的主流方式</li><li>基础前提:应用的容器化和微服务化。容器,作为应用部署、运行和管理的基本单元</li><li>核心:借助容器管理自动化平台进行动态编排和资源优化利用</li></ul><h2 id="云原生应用的三大特征"><a href="#云原生应用的三大特征" class="headerlink" title="云原生应用的三大特征"></a>云原生应用的三大特征</h2><h3 id="容器化封装"><a href="#容器化封装" class="headerlink" title="容器化封装"></a>容器化封装</h3><p>最近几年Docker容器化技术很火，经常在各种场合能够听到关于 <code>Docker</code> 的分享。<code>Docker</code> 让开发工程师可以将他们的应用和依赖封装到一个可移植的容器中。<code>Docker</code> 背后的想法是创建软件程序可移植的轻量容器，让其可以在任何安装了 <code>Docker</code> 的机器上运行，而不用关心底层操作系统。</p><p><code>Docker</code> 可以解决虚拟机能够解决的问题，同时也能够解决虚拟机由于资源要求过高而无法解决的问题。其优势包1括：</p><ul><li>隔离应用依赖</li><li>创建应用镜像并进行复制</li><li>创建容易分发的即启即用的应用</li><li>允许实例简单、快速地扩展</li><li>测试应用并随后销毁它们</li></ul><p>自动化运维工具可以降低环境搭建的复杂度，但仍然不能从根本上解决环境的问题。在看似稳定而成熟的场景下，使用 <code>Docker</code> 的好处越来越多。</p><h3 id="服务编排-动态管理"><a href="#服务编排-动态管理" class="headerlink" title="服务编排 动态管理"></a>服务编排 动态管理</h3><p><a href="https://jimmysong.io/posts/from-kubernetes-to-cloud-native/">Jimmy Song</a> 对云原生架构中运用服务编排的总结是：</p><blockquote><p>Kubernetes——让容器应用进入大规模工业生产</p></blockquote><p>编排调度的开源组件还有：<code>Kubernetes</code>、<code>Mesos</code> 和 <code>Docker Swarm</code>;</p><p>他们为云原生应用提供的强有力的编排和调度能力，它们是云平台上的分布式操作系统。在单机上运行容器，无法发挥它的最大效能，只有形成集群，才能最大程度发挥容器的良好隔离、资源分配与编排管理的优势</p><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>近几年微服务架构（<code>Micro-Service</code>，<code>Archeticture</code>）是最流行的架构风格，旨在通过将功能模块分解到各个独立的子系统中以实现解耦，它并没有一成不变的规定，而是需要根据业务来做设计。微服务架构是对SOA的传承，是SOA的具体实践方法。微服务架构中，每个微服务模块只是对简单、独立、明确的任务进行处理，通过REST API返回处理结果给外部。在微服务推广实践角度来看，微服务将整个系统进行拆分，拆分成更小的粒度，保持这些服务独立运行，应用容器化技术将微服务独立运行在容器中。过去设计架构时，是在内存中以参数或对象的方式实现粒度细化。微服务使用各个子服务控制模块的思想代替总线。不同的业务要求，服务控制模块至少包含服务的发布、注册、路由、代理功能。</p><p>容器化的出现，一定程度上带动了微服务架构。架构演化从单体式应用到分布式，再从分布式架构到云原生架构，微服务在其中有着不可或缺的角色。微服务带给我们很多开发和部署上的灵活性和技术多样性，但是也增加了服务调用的开销、分布式系事务、调试与服务治理方面的难题。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>技术架构的演变非常快，各种新的名词也是层出不穷。本文主要是对云原生的概述。云原生应用的三大特征：容器化封装、动态管理、面向微服务。首先由CNCF组织介绍了云原生的概念，然后分别对这三个特征进行详述。云原生架构是当下很火的讨论话题，是不同思想的集合，集目前各种热门技术之大成</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是云原生&quot;&gt;&lt;a href=&quot;#什么是云原生&quot; class=&quot;headerlink&quot; title=&quot;什么是云原生&quot;&gt;&lt;/a&gt;什么是云原生&lt;/h2&gt;&lt;h3 id=&quot;CNCF组织&quot;&gt;&lt;a href=&quot;#CNCF组织&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="设计开发" scheme="https://liei.cc/blog/categories/%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Docker" scheme="https://liei.cc/blog/tags/docker/"/>
    
    <category term="Cloud Navite" scheme="https://liei.cc/blog/tags/cloud-navite/"/>
    
    <category term="Kubernetes" scheme="https://liei.cc/blog/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>优化睡觉的沙发</title>
    <link href="https://liei.cc/2018/optimization-blog-theme.html"/>
    <id>https://liei.cc/2018/optimization-blog-theme.html</id>
    <published>2018-08-20T06:15:15.000Z</published>
    <updated>2018-08-20T06:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>博客太久没动了，刚好没事做的时候，就特别改博客主题，感觉像是强迫症，得改~</p><p>玩博客久了，就像谈恋爱，刚开始很美好，久而久之，问题就冒出来，总想让她变的更好，</p><p>其实这些都是次要的，我也知道更应该专注文章的内容，哎……</p></blockquote><h2 id="集成Gitment"><a href="#集成Gitment" class="headerlink" title="集成Gitment"></a>集成Gitment</h2><p><a href="https://github.com/imsun/gitment"><strong>Gitment</strong></a> 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub/Coding Pages 的静态博客或项目页面</p><ul><li><a href="https://github.com/imsun/gitment"><strong>项目地址</strong></a></li><li><a href="https://imsun.github.io/gitment/"><strong>示例页面</strong></a></li></ul><p>当然，人家作者也说了，着这个项目的时候考虑过到底有没有滥用 GitHub ，为此还特地 Email 了官方，GitHub 给出的回复是：</p><blockquote><p>We’re pleased to see you making use of the tools and resources available on GitHub.</p></blockquote><p>所以啊，我们在使用的时候，也要恪尽职守，维护一个好的开源环境，善用 <code>GitHub</code></p><p>好了，说多了，下面开始：</p><h3 id="注册-OAuth-Application"><a href="#注册-OAuth-Application" class="headerlink" title="注册 OAuth Application"></a>注册 OAuth Application</h3><p><a href="https://github.com/settings/applications/new">点击此处</a> 来注册一个新的 OAuth Application，成功之后就会拿到 <code>Client ID</code> 和 <code>Client Secret</code></p><h3 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h3><pre><code class="hljs yaml"><span class="hljs-comment">##############################################################################</span><span class="hljs-comment"># Plugins</span><span class="hljs-comment">##############################################################################</span><span class="hljs-comment">## Gitment</span><span class="hljs-attr">gitment:</span>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">owner:</span> <span class="hljs-string">your_id</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">your_repo</span>  <span class="hljs-attr">client_id:</span> <span class="hljs-string">your_client_id</span>  <span class="hljs-attr">client_secret:</span> <span class="hljs-string">your_client_secret</span></code></pre><h3 id="为-Gitment-添加-layout-布局"><a href="#为-Gitment-添加-layout-布局" class="headerlink" title="为 Gitment 添加 layout 布局"></a>为 Gitment 添加 layout 布局</h3><p>这里以我的主题 <a href="https://github.com/probberechts/hexo-theme-cactus"><strong>cactus</strong></a> 为例，在 <code>layout/_partial/comments.ejs</code> 下列代添加码：</p><pre><code class="hljs ejs">&lt;% if(is_post() || page.comments) &#123; %&gt;&lt;div id&#x3D;&quot;gitment_title&quot; class&#x3D;&quot;gitment_title&quot;&gt;&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;container&quot; style&#x3D;&quot;display:none&quot;&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;imsun.github.io&#x2F;gitment&#x2F;dist&#x2F;gitment.browser.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;  const myTheme &#x3D; &#123;    render(state, instance) &#123;      const container &#x3D; document.createElement(&#39;div&#39;);      container.lang &#x3D; &quot;en-US&quot;;      container.className &#x3D; &#39;gitment-container gitment-root-container&#39;;      container.appendChild(instance.renderHeader(state, instance));      container.appendChild(instance.renderEditor(state, instance));      container.appendChild(instance.renderComments(state, instance));      container.appendChild(instance.renderFooter(state, instance));      return container;    &#125;  &#125;  function showGitment() &#123;    $(&quot;#gitment_title&quot;).attr(&quot;style&quot;, &quot;display:none&quot;);    $(&quot;#container&quot;).attr(&quot;style&quot;, &quot;&quot;).addClass(&quot;gitment_container&quot;);    var gitment &#x3D; new Gitment(&#123;      id: decodeURI(window.location.pathname),      theme: myTheme,      owner: &quot;&lt;%&#x3D;theme.gitment.owner%&gt;&quot;,      repo: &quot;&lt;%&#x3D;theme.gitment.repo%&gt;&quot;,      oauth: &#123;          client_id: &quot;&lt;%&#x3D;theme.gitment.client_id%&gt;&quot;,          client_secret: &quot;&lt;%&#x3D;theme.gitment.client_secret%&gt;&quot;      &#125;    &#125;);    gitment.render(&#39;container&#39;);  &#125;  showGitment();&lt;&#x2F;script&gt;&lt;% &#125; %&gt;</code></pre><h3 id="为-Gitment-添加样式"><a href="#为-Gitment-添加样式" class="headerlink" title="为 Gitment 添加样式"></a>为 Gitment 添加样式</h3><p><a href="https://github.com/leeifme/leeifme.github.io/blob/hexo/themes/cactus/source/css/_gitment.styl"><strong>_gitment.styl</strong></a> 这是我自定义的 Gitment 的样式文件，比较契合我的主题 <code>cactus</code> ，可以自行修改；将样式文件拷贝到 <code>source/css/</code> 目录下</p><p><strong>引入 Gitment 样式</strong></p><p>在 <code>source/css/style.styl</code> 文件中，添加：</p><pre><code class="hljs stylus"><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;_gitment.styl&quot;</span></code></pre><p>ok，更新博客，就可以看到评论了</p><h2 id="主题首页添加-一言"><a href="#主题首页添加-一言" class="headerlink" title="主题首页添加 一言"></a>主题首页添加 一言</h2><blockquote><p>一言：随机一句话副标题，</p><p>可以是一本书，一部电影，一句歌词，</p><p>可以是中文，英文，日语，</p><p>总之是一句话</p></blockquote><p>感谢作者：<a href="https://github.com/isecret"><strong>isecret</strong></a>，是从他他制作的 Hexo 主题 <a href="https://github.com/isecret/Hola"><strong>Hola</strong></a> 获取的灵感</p><h3 id="修改主题配置文件-1"><a href="#修改主题配置文件-1" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h3><pre><code class="hljs yaml"><span class="hljs-comment">##############################################################################</span><span class="hljs-comment"># Plugins</span><span class="hljs-comment">##############################################################################</span><span class="hljs-comment">## 一言</span><span class="hljs-attr">hitokoto:</span> <span class="hljs-string">enabled</span></code></pre><h3 id="为一言添加-layout-布局"><a href="#为一言添加-layout-布局" class="headerlink" title="为一言添加 layout 布局"></a>为一言添加 layout 布局</h3><p>在 <code>layout/index.styl</code> 文件中的 <code>&lt;section id=&quot;about&quot;&gt;</code> 内添加：</p><pre><code class="hljs stylus">&lt;% if (theme.hitokoto == &#x27;enabled&#x27;) &#123; %&gt;    &lt;p&gt;      &lt;script&gt;          fetch(<span class="hljs-string">&#x27;https://api.hitokoto.cn&#x27;</span>)              <span class="hljs-selector-class">.then</span>(function (res)&#123;                  return res.json();              &#125;)              <span class="hljs-selector-class">.then</span>(function (data) &#123;                  var hitokoto = document.getElementById(&#x27;hitokoto&#x27;);                  hitokoto.innerText =  data.hitokoto + &#x27; ——&#x27; + &#x27;『&#x27; + data.from + &#x27;』&#x27;;              &#125;)              <span class="hljs-selector-class">.catch</span>(function (err) &#123;                  console.error(err);              &#125;);      &lt;/script&gt;      &lt;<span class="hljs-selector-tag">a</span> id=<span class="hljs-string">&quot;hitokoto&quot;</span>&gt;&lt;/a&gt;    &lt;/p&gt; &lt;% &#125; %&gt;</code></pre><p><a href="https://leeif.me/"><strong>演示地址</strong></a> </p><h2 id="gulp-文件压缩"><a href="#gulp-文件压缩" class="headerlink" title="gulp 文件压缩"></a>gulp 文件压缩</h2><h3 id="安装-npm-依赖组件"><a href="#安装-npm-依赖组件" class="headerlink" title="安装 npm 依赖组件"></a>安装 npm 依赖组件</h3><pre><code class="hljs bash"><span class="hljs-comment"># 在站点的根目录下执行以下命令</span>npm install gulp -gnpm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save<span class="hljs-comment"># 模块作用</span>gulp-htmlclean // 清理htmlgulp-htmlmin // 压缩htmlgulp-minify-css // 压缩cssgulp-uglify // 混淆jsgulp-imagemin // 压缩图片</code></pre><h3 id="新建-gulp-配置"><a href="#新建-gulp-配置" class="headerlink" title="新建 gulp 配置"></a>新建 gulp 配置</h3><pre><code class="hljs js"><span class="hljs-comment">/* 在站点根目录添加 gulpfile.js 文件，内容如下： */</span><span class="hljs-keyword">var</span> gulp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp&#x27;</span>);<span class="hljs-keyword">var</span> minifycss = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-minify-css&#x27;</span>);<span class="hljs-keyword">var</span> uglify = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-uglify&#x27;</span>);<span class="hljs-keyword">var</span> htmlmin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-htmlmin&#x27;</span>);<span class="hljs-keyword">var</span> htmlclean = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-htmlclean&#x27;</span>);<span class="hljs-comment">// 压缩 public 目录 css</span>gulp.task(<span class="hljs-string">&#x27;minify-css&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> gulp.src(<span class="hljs-string">&#x27;./public/**/*.css&#x27;</span>)        .pipe(minifycss())        .pipe(gulp.dest(<span class="hljs-string">&#x27;./public&#x27;</span>));&#125;);<span class="hljs-comment">// 压缩 public 目录 html</span>gulp.task(<span class="hljs-string">&#x27;minify-html&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> gulp.src(<span class="hljs-string">&#x27;./public/**/*.html&#x27;</span>)    .pipe(htmlclean())    .pipe(htmlmin(&#123;         removeComments: <span class="hljs-literal">true</span>,         minifyJS: <span class="hljs-literal">true</span>,         minifyCSS: <span class="hljs-literal">true</span>,         minifyURLs: <span class="hljs-literal">true</span>,    &#125;))    .pipe(gulp.dest(<span class="hljs-string">&#x27;./public&#x27;</span>))&#125;);<span class="hljs-comment">// 压缩 public/js 目录 js</span>gulp.task(<span class="hljs-string">&#x27;minify-js&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> gulp.src(<span class="hljs-string">&#x27;./public/**/*.js&#x27;</span>)        .pipe(uglify())        .pipe(gulp.dest(<span class="hljs-string">&#x27;./public&#x27;</span>));&#125;);<span class="hljs-comment">// 执行 gulp 命令时执行的任务</span>gulp.task(<span class="hljs-string">&#x27;default&#x27;</span>, [    <span class="hljs-string">&#x27;minify-html&#x27;</span>,<span class="hljs-string">&#x27;minify-css&#x27;</span>,<span class="hljs-string">&#x27;minify-js&#x27;</span>]);</code></pre><h3 id="部署命令"><a href="#部署命令" class="headerlink" title="部署命令"></a>部署命令</h3><p>在站点根目录执行 <code>gulp</code> 命令，就能压缩 <code>public</code> 文件夹里面的文件了</p><pre><code class="hljs bash">hexo g &amp;&amp; gulp;hexo d;</code></pre><blockquote><p>后续有其他优化，会持续更新的……</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;博客太久没动了，刚好没事做的时候，就特别改博客主题，感觉像是强迫症，得改~&lt;/p&gt;
&lt;p&gt;玩博客久了，就像谈恋爱，刚开始很美好，久而久之，问题就冒出来，总想让她变的更好，&lt;/p&gt;
&lt;p&gt;其实这些都是次要的，我也知道更应该专注文章的内容，哎……&lt;/p</summary>
      
    
    
    
    <category term="折腾不止" scheme="https://liei.cc/blog/categories/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2/"/>
    
    
    <category term="Hexo" scheme="https://liei.cc/blog/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>你和大佬之间就差一个 vim</title>
    <link href="https://liei.cc/2018/vim-common-hotkey.html"/>
    <id>https://liei.cc/2018/vim-common-hotkey.html</id>
    <published>2018-08-15T06:15:15.000Z</published>
    <updated>2018-08-15T06:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进入-vim"><a href="#进入-vim" class="headerlink" title="进入 vim"></a>进入 vim</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>vim filename</td><td>打开或新建文件, 并将光标置于第一行首</td></tr><tr><td>vim +n filename</td><td>打开文件，并将光标置于第 n 行首</td></tr><tr><td>vim + filename</td><td>打开文件，并将光标置于最后一行首</td></tr><tr><td>vim +/pattern filename</td><td>打开文件，并将光标置于第一个与 pattern 匹配的串处</td></tr><tr><td>vim -r filename</td><td>在上次正用 vim 编辑时发生系统崩溃，恢复 filename</td></tr><tr><td>vim filename….filename</td><td>打开多个文件，依次编辑</td></tr></tbody></table><h2 id="vim-配置"><a href="#vim-配置" class="headerlink" title="vim 配置"></a>vim 配置</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>:set number / set nonumber</td><td>显示 / 不显示行号</td></tr><tr><td>:set ruler /set noruler</td><td>显示 / 不显示标尺</td></tr><tr><td>:set hlsearch</td><td>高亮显示查找到的单词</td></tr><tr><td>:set nohlsearch</td><td>关闭高亮显示</td></tr><tr><td>:syntax on</td><td>语法高亮</td></tr><tr><td>:set nu</td><td>显示行号</td></tr><tr><td>:set tabstop=8</td><td>设置 tab 大小, 8 为最常用最普遍的设置</td></tr><tr><td>:set softtabstop=8</td><td>4:4 个空格, 8: 正常的制表符, 12: 一个制表符 4 个空格, 16: 两个制表符</td></tr><tr><td>:set autoindent</td><td>自动缩进</td></tr><tr><td>:set cindent</td><td>C 语言格式里面的自动缩进</td></tr></tbody></table><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>k nk</td><td>上 向上移动 n 行</td></tr><tr><td>j nj</td><td>下 向下移动 n 行</td></tr><tr><td>h nh</td><td>左 向左移动 n 行</td></tr><tr><td>l nl</td><td>右 向右移动 n 行</td></tr><tr><td>Space</td><td>光标右移一个字符</td></tr><tr><td>Backspace</td><td>光标左移一个字符</td></tr><tr><td>Enter</td><td>光标下移一行</td></tr><tr><td>w/W</td><td>光标右移一个字至字首</td></tr><tr><td>b/B</td><td>光标左移一个字至字首</td></tr><tr><td>e 或 E</td><td>光标右移一个字至字尾</td></tr><tr><td>)</td><td>光标移至句尾</td></tr><tr><td>(</td><td>光标移至句首</td></tr><tr><td>}</td><td>光标移至段落开头</td></tr><tr><td>{</td><td>光标移至段落结尾</td></tr><tr><td>n$</td><td>光标移至第 n 行尾</td></tr><tr><td>H</td><td>光标移至屏幕顶行</td></tr><tr><td>M</td><td>光标移至屏幕中间行</td></tr><tr><td>L</td><td>光标移至屏幕最后行</td></tr><tr><td>0</td><td>（注意是数字零）光标移至当前行首</td></tr><tr><td>^</td><td>移动光标到行首第一个非空字符上去</td></tr><tr><td>$</td><td>光标移至当前行尾</td></tr><tr><td>gg</td><td>移到第一行</td></tr><tr><td>G</td><td>移到最后一行</td></tr><tr><td>f</td><td>移动光标到当前行的字符 a 上</td></tr><tr><td>F</td><td>相反</td></tr><tr><td>%</td><td>移动到与制匹配的括号上去（），{}，[]，&lt;&gt; 等</td></tr><tr><td>nG</td><td>移动到第 n 行上</td></tr><tr><td>G</td><td>到最后一行</td></tr></tbody></table><h2 id="屏幕滚动"><a href="#屏幕滚动" class="headerlink" title="屏幕滚动"></a>屏幕滚动</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>Ctrl+u</td><td>向文件首翻半屏</td></tr><tr><td>Ctrl+d</td><td>向文件尾翻半屏</td></tr><tr><td>Ctrl+f</td><td>向文件尾翻一屏</td></tr><tr><td>Ctrl＋b</td><td>向文件首翻一屏</td></tr><tr><td>nz</td><td>将第 n 行滚至屏幕顶部，不指定 n 时将当前行滚至屏幕顶部</td></tr></tbody></table><h2 id="插入文本类"><a href="#插入文本类" class="headerlink" title="插入文本类"></a>插入文本类</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>i</td><td>在光标前</td></tr><tr><td>I</td><td>在当前行首</td></tr><tr><td>a</td><td>光标后</td></tr><tr><td>A</td><td>在当前行尾</td></tr><tr><td>o</td><td>在当前行之下新开一行</td></tr><tr><td>O</td><td>在当前行之上新开一行</td></tr><tr><td>r</td><td>替换当前字符</td></tr><tr><td>R</td><td>替换当前字符及其后的字符，直至按 ESC 键</td></tr><tr><td>s</td><td>从当前光标位置处开始，以输入的文本替代指定数目的字符</td></tr><tr><td>S</td><td>删除指定数目的行，并以所输入文本代替之</td></tr><tr><td>ncw/nCW</td><td>修改指定数目的字</td></tr><tr><td>nCC</td><td>修改指定数目的行</td></tr></tbody></table><h2 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>x/X</td><td>删除一个字符，x 删除光标后的，而 X 删除光标前的</td></tr><tr><td>dw</td><td>删除一个单词 (删除光标位置到下一个单词开始的位置)</td></tr><tr><td>dnw</td><td>删除 n 个单词</td></tr><tr><td>dne</td><td>也可，只是删除到单词尾</td></tr><tr><td>do</td><td>删至行首</td></tr><tr><td>d$</td><td>删至行尾</td></tr><tr><td>dd</td><td>删除一行</td></tr><tr><td>ndd</td><td>删除当前行及其后 n-1 行</td></tr><tr><td>dnl</td><td>向右删除 n 个字母</td></tr><tr><td>dnh</td><td>向左删除 n 个字母</td></tr><tr><td>dnj</td><td>向下删除 n 行, 当前行 + 其上 n 行</td></tr><tr><td>dnk</td><td>向上删除 n 行, 当期行 + 其下 n 行</td></tr><tr><td>cnw[word]</td><td>将 n 个 word 改变为 word</td></tr><tr><td>C$</td><td>改变到行尾</td></tr><tr><td>cc</td><td>改变整行</td></tr><tr><td>shift+j</td><td>删除行尾的换行符，下一行接上来了</td></tr></tbody></table><h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>p</td><td>粘贴用 x 或 d 删除的文本</td></tr><tr><td>ynw</td><td>复制 n 个单词</td></tr><tr><td>yy</td><td>复制一行</td></tr><tr><td>ynl</td><td>复制 n 个字符</td></tr><tr><td>y$</td><td>复制当前光标至行尾处</td></tr><tr><td>nyy</td><td>拷贝 n 行</td></tr></tbody></table><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>u</td><td>撤销前一次的操作</td></tr><tr><td>shif+u(U)</td><td>撤销对该行的所有操作</td></tr></tbody></table><h2 id="搜索及替换"><a href="#搜索及替换" class="headerlink" title="搜索及替换"></a>搜索及替换</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>/pattern</td><td>从光标开始处向文件尾搜索 pattern</td></tr><tr><td>?pattern</td><td>从光标开始处向文件首搜索 pattern</td></tr><tr><td>n</td><td>在同一方向重复上一次搜索命令</td></tr><tr><td>N</td><td>在反方向上重复上一次搜索命令</td></tr><tr><td>cw newword</td><td>替换为 newword</td></tr><tr><td>n</td><td>继续查找</td></tr><tr><td>.</td><td>执行替换</td></tr><tr><td>:s/p1/p2/g</td><td>将当前行中所有 p1 均用 p2 替代, g 表示执行 用 c 表示需要确认</td></tr><tr><td>:n1,n2 s/p1/p2/g</td><td>将第 n1 至 n2 行中所有 p1 均用 p2 替代</td></tr><tr><td>:g/p1/s//p2/g</td><td>将文件中所有 p1 均用 p2 替换</td></tr><tr><td>:1,$ s/string1/string2/g</td><td>在全文中将 string1 替换为 string2</td></tr></tbody></table><h2 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>m[a-z]</td><td>在文中做标记，标记号可为 a-z 的 26 个字母</td></tr><tr><td>`a</td><td>移动到标记 a 处</td></tr></tbody></table><h2 id="visual-模式"><a href="#visual-模式" class="headerlink" title="visual 模式"></a>visual 模式</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>v</td><td>进入 visual 模式</td></tr><tr><td>V</td><td>进入行的 visual 模式</td></tr><tr><td>ctrl+v</td><td>进如块操作模式用 o 和 O 改变选择的边的大小</td></tr><tr><td>在所有行插入相同的内容如 include&lt;</td><td>将光标移到开始插入的位置，按 CTRL+V 进入 VISUAL 模式，选择好模块后按 I（shift+i)，后插入要插入的文本，按 [ESC] 完成</td></tr></tbody></table><h2 id="行方式命令"><a href="#行方式命令" class="headerlink" title="行方式命令"></a>行方式命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>:n1,n2 co n3 或者 :n1,n2 copy n3</td><td>将 n1 行到 n2 行之间的内容拷贝到第 n3 行下</td></tr><tr><td>:n1,n2 m n3 或者 :n1,n2 move n3</td><td>将 n1 行到 n2 行之间的内容移至到第 n3 行下</td></tr><tr><td>:n1,n2 d</td><td>将 n1 行到 n2 行之间的内容删除</td></tr><tr><td>:n1,n2 w!command</td><td>将文件中 n1 行至 n2 行的内容作为 command 的输入并执行之</td></tr><tr><td>若不指定 n1，n2，则表示将整个文件内容作为 command 的输入</td><td></td></tr></tbody></table><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>q[a-z]</td><td>开始记录但前开始的操作为宏，名称可为【a-z】，然后用 q 终止录制宏</td></tr><tr><td>reg</td><td>显示当前定义的所有的宏，用 @[a-z] 来在当前光标处执行宏 [a-z]</td></tr></tbody></table><h2 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>:split</td><td>分割一个窗口</td></tr><tr><td>:split file.c</td><td>为另一个文件 file.c 分隔窗口</td></tr><tr><td>:nsplit file.c</td><td>为另一个文件 file.c 分隔窗口，并指定其行数</td></tr><tr><td>ctrl＋w</td><td>在窗口中切换</td></tr><tr><td>:close</td><td>关闭当前窗口</td></tr></tbody></table><h2 id="文件及其他"><a href="#文件及其他" class="headerlink" title="文件及其他"></a>文件及其他</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>:q</td><td>退出 vi</td></tr><tr><td>:q!</td><td>不保存文件并退出 vi</td></tr><tr><td>:e filename</td><td>打开文件 filename 进行编辑</td></tr><tr><td>:e!</td><td>放弃修改文件内容，重新载入该文件编辑</td></tr><tr><td>:w</td><td>保存当前文件</td></tr><tr><td>:wq</td><td>存盘退出</td></tr><tr><td>:ZZ</td><td>保存当前文档并退出 VIM</td></tr><tr><td>:!command</td><td>执行 shell 命令 command</td></tr><tr><td>:r!command</td><td>将命令 command 的输出结果放到当前行</td></tr><tr><td>:read file.c</td><td>将文件 file.c 的内容插入到当前光标所在的下面</td></tr></tbody></table><h2 id="常用正则"><a href="#常用正则" class="headerlink" title="常用正则"></a>常用正则</h2><ul><li>删除行尾空格：<code>:%s/\s+$//g</code></li><li>删除行首多余空格：<code>%s/^\s*//</code> 或者 <code>%s/^ *//</code></li><li>删除沒有內容的空行：<code>%s/^$//</code> 或者 <code>g/^$/d</code></li><li>删除包含有空格组成的空行：<code>%s/^\s*$//</code> 或者 <code>g/^\s*$/d</code></li><li>删除以空格或 TAB 开头到结尾的空行：<code>%s/^[ |\t]*$//</code> 或者 <code>g/^[ |\t]*$/d</code></li><li>清空某一行或多行文本：<code>:n1,n2 s/\w//g</code></li><li>给一行或多行首字符添加注释：<code>n1,n2 s/^/#/g</code></li><li>给一行或多行首字符删除注释：<code>n1,n2 s/^#//g</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进入-vim&quot;&gt;&lt;a href=&quot;#进入-vim&quot; class=&quot;headerlink&quot; title=&quot;进入 vim&quot;&gt;&lt;/a&gt;进入 vim&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thea</summary>
      
    
    
    
    <category term="安利系列" scheme="https://liei.cc/blog/categories/%E5%AE%89%E5%88%A9%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Linux" scheme="https://liei.cc/blog/tags/linux/"/>
    
    <category term="Vim" scheme="https://liei.cc/blog/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>gin-swagger 自动化构建 API 文档</title>
    <link href="https://liei.cc/2018/gin-swagger-build-document.html"/>
    <id>https://liei.cc/2018/gin-swagger-build-document.html</id>
    <published>2018-07-27T12:36:25.000Z</published>
    <updated>2018-07-27T12:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前后端的交互一般流程是这样的，后端暴露出 API 后，交给前端，前端根据 API 的响应，编写前端页面，一定程度上 API 是前后端的交互桥梁。 </p></blockquote><p>API 文档主要要包含:</p><ul><li>路由：包括路径参数、请求参数、还是请求体参数</li><li>动作：HTTP 请求动作，GET、POST、DELETE、PUT</li><li>响应：请求之后的返回值包含哪些信息，一般是 JSON</li></ul><p>swagger 可以将代码和 api 文档维护在一起，通过访问服务进程的 swagger 页面就可以得到完善的 api 文档，还可以直接 Try out。 </p><h2 id="doc文档"><a href="#doc文档" class="headerlink" title="doc文档"></a>doc文档</h2><ul><li><a href="https://github.com/swaggo/gin-swagger"><strong>gin-swagger</strong></a></li><li><a href="https://swaggo.github.io/swaggo.io/declarative_comments_format/"><strong>swagger-doc</strong></a></li></ul><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><ol><li>要知道 swagger 注释的语法</li><li>如何在 gin 内怎么使用</li></ol><p>注释语法这个，全靠查文档。对着文档来。</p><p>当然我觉得最好的方法是什么呢，是模仿，找一个别人已经写好的，修修改改，看看能不能编译通过，编译通过后是不是你预期的结果。不是的话，继续修修改改，再编译，再看是不是你希望的结果。如此反复。</p><p><img src="http://orj2jcr7i.bkt.clouddn.com/blog/180727/2im5i3b45e.png?imageslim" alt="mark"></p><h4 id="1-编写全局信息注释，在主函数上编写"><a href="#1-编写全局信息注释，在主函数上编写" class="headerlink" title="1. 编写全局信息注释，在主函数上编写"></a>1. 编写全局信息注释，在主函数上编写</h4><p>格式：<code>// @param info</code></p><pre><code class="hljs go"><span class="hljs-comment">// @title Swagger Example API</span><span class="hljs-comment">// @version 1.0</span><span class="hljs-comment">// @description This is a sample server Petstore server.</span><span class="hljs-comment">// @termsOfService http://swagger.io/terms/</span><span class="hljs-comment">// @contact.name API Support</span><span class="hljs-comment">// @contact.url http://www.swagger.io/support</span><span class="hljs-comment">// @contact.email support@swagger.io</span><span class="hljs-comment">// @license.name Apache 2.0</span><span class="hljs-comment">// @license.url http://www.apache.org/licenses/LICENSE-2.0.html</span><span class="hljs-comment">// @host 127.0.0.1:8080</span><span class="hljs-comment">// @BasePath /v1</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    r := gin.Default()    r.GET(<span class="hljs-string">&quot;/docs/*any&quot;</span>, ginSwagger.WrapHandler(swaggerFiles.Handler))    r.GET(<span class="hljs-string">&quot;v1/hello/:name&quot;</span>, Name)    r.Run()&#125;</code></pre><pre><code class="hljs plain">r.GET(&quot;&#x2F;docs&#x2F;*any&quot;, ginSwagger.WrapHandler(swaggerFiles.Handler))</code></pre><p>这个路由和响应需要有，路由随便的定义，但我觉得我这种方式一目了然，知道是文档。</p><p>其他注释对照着参考文档即可。</p><h4 id="2-编写应用注释"><a href="#2-编写应用注释" class="headerlink" title="2. 编写应用注释"></a>2. 编写应用注释</h4><p>即在响应函数的上方编写注释</p><pre><code class="hljs go"><span class="hljs-comment">// Name will print hello name</span><span class="hljs-comment">// @Summary Print</span><span class="hljs-comment">// @Accept json</span><span class="hljs-comment">// @Tags Name</span><span class="hljs-comment">// @Security Bearer</span><span class="hljs-comment">// @Produce  json</span><span class="hljs-comment">// @Param name path string true &quot;name&quot;</span><span class="hljs-comment">// @Resource Name</span><span class="hljs-comment">// @Router /hello/&#123;name&#125; [get]</span><span class="hljs-comment">// @Success 200 &#123;object&#125; main.Message</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Name</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;    name := c.Param(<span class="hljs-string">&quot;name&quot;</span>)    <span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;&quot;</span> &#123;        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">var</span> message Message    message = Message&#123;        MessageInfo: fmt.Sprintf(<span class="hljs-string">&quot;hello %s&quot;</span>, name),    &#125;    c.JSON(http.StatusOK, message.Serializer())&#125;</code></pre><p>这里最好把响应体统一成结构体的形式。即</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Message <span class="hljs-keyword">struct</span> &#123;    MessageInfo <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;message&quot;`</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Message)</span> <span class="hljs-title">Serializer</span><span class="hljs-params">()</span><span class="hljs-title">Message</span></span>&#123;    <span class="hljs-keyword">return</span> Message&#123;        MessageInfo: m.MessageInfo,    &#125;&#125;</code></pre><h4 id="3-目录下-执行命令"><a href="#3-目录下-执行命令" class="headerlink" title="3. 目录下 执行命令"></a>3. 目录下 执行命令</h4><pre><code class="hljs go">swag init</code></pre><p>自动生成 docs 文件夹，内含 swagger.json 、swagger.json 、 docs.go</p><p>编译不通过，查看报错信息，修改注释。</p><h4 id="4-导入生成的-docs-文件"><a href="#4-导入生成的-docs-文件" class="headerlink" title="4. 导入生成的 docs 文件"></a>4. 导入生成的 docs 文件</h4><pre><code class="hljs go"><span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;github.com/swaggo/gin-swagger&quot;</span>    <span class="hljs-string">&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span>    _ <span class="hljs-string">&quot;./docs&quot;</span> <span class="hljs-comment">// docs is generated by Swag CLI, you have to import it.</span>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span>    <span class="hljs-string">&quot;net/http&quot;</span>    <span class="hljs-string">&quot;fmt&quot;</span>)</code></pre><p>即这个  <code>./docs</code></p><h4 id="5-go-run-main-go"><a href="#5-go-run-main-go" class="headerlink" title="5. go run main.go"></a>5. go run main.go</h4><p>访问：<code>http://127.0.0.1:8080/docs/index.html</code></p><p>即可查看 swagger 文档。</p><p><img src="http://orj2jcr7i.bkt.clouddn.com/blog/180727/hidH469gKB.png?imageslim" alt="mark"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前后端的交互一般流程是这样的，后端暴露出 API 后，交给前端，前端根据 API 的响应，编写前端页面，一定程度上 API 是前后端的交互桥梁。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;API 文档主要要包含:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路由：</summary>
      
    
    
    
    <category term="技术加油站" scheme="https://liei.cc/blog/categories/%E6%8A%80%E6%9C%AF%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    
    
    <category term="Go" scheme="https://liei.cc/blog/tags/go/"/>
    
  </entry>
  
</feed>
